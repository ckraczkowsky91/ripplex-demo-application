"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const addressCodec = __importStar(require("ripple-address-codec"));
const utils_1 = __importDefault(require("../Common/utils"));
const xrpl_network_1 = __importDefault(require("./xrpl-network"));
/**
 * A prefix applied when hashing a signed transaction blob.
 *
 * @see Https://xrpl.org/basic-data-types.html#hashes.
 */
const signedTransactionPrefixHex = '54584E00';
const xrpUtils = {
    /**
     * Validate that the given string is a valid address for the XRP Ledger.
     *
     * This function returns true for both X-addresses and classic addresses.
     *
     * @see Https://xrpaddress.info/.
     *
     * @param address - An address to check.
     * @returns True if the address is valid, otherwise false.
     */
    isValidAddress(address) {
        return (addressCodec.isValidClassicAddress(address) ||
            addressCodec.isValidXAddress(address));
    },
    /**
     * Validate whether the given string is a valid X-address for the XRP Ledger.
     *
     * @see Https://xrpaddress.info/.
     *
     * @param address - An address to check.
     * @returns True if the address is a valid X-address, otherwise false.
     */
    isValidXAddress(address) {
        return addressCodec.isValidXAddress(address);
    },
    /**
     * Validate whether the given string is a valid classic address for the XRP Ledger.
     *
     * @see Https://xrpaddress.info/.
     *
     * @param address - An address to check.
     * @returns True if the address is a valid classic address, otherwise false.
     */
    isValidClassicAddress(address) {
        return addressCodec.isValidClassicAddress(address);
    },
    /**
     * Encode the given classic address and tag into an x-address.
     *
     * @see Https://xrpaddress.info/.
     *
     * @param classicAddress - A classic address to encode.
     * @param tag - An optional tag to encode.
     * @param test - Whether the address is for use on a test network, defaults to `false`.
     * @returns A new x-address if inputs were valid, otherwise undefined.
     */
    encodeXAddress(classicAddress, tag, test = false) {
        if (!addressCodec.isValidClassicAddress(classicAddress)) {
            return undefined;
        }
        // Xpring Common JS's API takes a string|undefined while the underlying address library wants string|false.
        const shimTagParameter = tag !== null && tag !== void 0 ? tag : false;
        return addressCodec.classicAddressToXAddress(classicAddress, shimTagParameter, test);
    },
    /**
     * Decode a `ClassicAddress` from a given x-address.
     *
     * @see Https://xrpaddress.info/.
     *
     * @param xAddress - The xAddress to decode.
     * @returns A `ClassicAddress`.
     */
    decodeXAddress(xAddress) {
        if (!addressCodec.isValidXAddress(xAddress)) {
            return undefined;
        }
        const shimClassicAddress = addressCodec.xAddressToClassicAddress(xAddress);
        return {
            address: shimClassicAddress.classicAddress,
            tag: shimClassicAddress.tag === false ? undefined : shimClassicAddress.tag,
            test: shimClassicAddress.test,
        };
    },
    /**
     * Convert the given transaction blob to a transaction hash.
     *
     * @param transactionBlobHex - A hexadecimal encoded transaction blob.
     * @returns A hex encoded hash if the input was valid, otherwise undefined.
     */
    transactionBlobToTransactionHash(transactionBlobHex) {
        if (!utils_1.default.isHex(transactionBlobHex)) {
            return undefined;
        }
        const prefixedTransactionBlob = utils_1.default.toBytes(signedTransactionPrefixHex + transactionBlobHex);
        const hash = utils_1.default.sha512Half(prefixedTransactionBlob);
        return utils_1.default.toHex(hash);
    },
    /**
     * Returns whether the given `XrplNetwork` is a test network.
     *
     * @param network - The network to check.
     * @returns A boolean indicating if the network is a test network.
     */
    isTestNetwork(network) {
        return network === xrpl_network_1.default.Test || network === xrpl_network_1.default.Dev;
    },
};
exports.default = xrpUtils;
//# sourceMappingURL=xrp-utils.js.map