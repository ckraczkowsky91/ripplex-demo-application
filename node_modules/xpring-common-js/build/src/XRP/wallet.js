"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bip32 = __importStar(require("bip32"));
const bip39 = __importStar(require("bip39"));
const rippleKeyPair = __importStar(require("ripple-keypairs"));
const utils_1 = __importDefault(require("../Common/utils"));
const xrp_utils_1 = __importDefault(require("./xrp-utils"));
/**
 * A wallet object that has an address and keypair.
 */
class Wallet {
    /**
     * Create a new Wallet object.
     *
     * @param publicKey - The given public key for the wallet.
     * @param privateKey - The given private key for the wallet.
     * @param test - Whether the address is for use on a test network, defaults to `false`.
     */
    constructor(publicKey, privateKey, test = false) {
        this.publicKey = publicKey;
        this.privateKey = privateKey;
        this.test = test;
    }
    /**
     * Generate a new wallet hierarchical deterministic wallet with a random mnemonic and
     * default derivation path.
     *
     * Secure random number generation is used when entropy is omitted and when the runtime environment has the necessary support.
     * Otherwise, an error is thrown.
     *
     * Runtime environments that do not have secure random number generation should pass their own buffer of entropy.
     *
     * @deprecated Please use methods on `WalletFactory` to generate wallets instead.
     *
     * @param entropy - A optional hex string of entropy.
     * @param test - Whether the address is for use on a test network, defaults to `false`.
     * @returns Artifacts from the wallet generation.
     */
    static generateRandomWallet(entropy = undefined, test = false) {
        if (entropy && !utils_1.default.isHex(entropy)) {
            return undefined;
        }
        const mnemonic = entropy === undefined
            ? bip39.generateMnemonic()
            : bip39.entropyToMnemonic(entropy);
        const derivationPath = Wallet.defaultDerivationPath;
        const wallet = Wallet.generateWalletFromMnemonic(mnemonic, derivationPath, test);
        return wallet === undefined
            ? undefined
            : { wallet, mnemonic, derivationPath };
    }
    /**
     * Generate a new hierarchical deterministic wallet from a mnemonic and derivation path.
     *
     * @deprecated Please use methods on `WalletFactory` to generate wallets instead.
     *
     * @param mnemonic - The given mnemonic for the wallet.
     * @param derivationPath - The given derivation path to use. If undefined, the default path is used.
     * @param test - Whether the address is for use on a test network, defaults to `false`.
     * @returns A new wallet from the given mnemonic if the mnemonic was valid, otherwise undefined.
     */
    static generateWalletFromMnemonic(mnemonic, derivationPath = Wallet.defaultDerivationPath, test = false) {
        // Validate mnemonic and path are valid.
        if (!bip39.validateMnemonic(mnemonic)) {
            return undefined;
        }
        /* eslint-disable node/no-sync --
         * TODO:(@keefertaylor) To be fixed when we make a WalletFactory
         */
        const seed = bip39.mnemonicToSeedSync(mnemonic);
        /* eslint-enable node/no-sync */
        return Wallet.generateHDWalletFromSeed(seed, derivationPath, test);
    }
    /**
     * Generate a new hierarchical deterministic wallet from a seed and derivation path.
     *
     * @deprecated Please use methods on `WalletFactory` to generate wallets instead.
     *
     * @param seed - The given seed for the wallet.
     * @param derivationPath - The given derivation path to use. If undefined, the default path is used.
     * @param test - Whether the address is for use on a test network, defaults to `false`.
     * @returns A new wallet from the given mnemonic if the mnemonic was valid, otherwise undefined.
     */
    static generateHDWalletFromSeed(seed, derivationPath = Wallet.defaultDerivationPath, test = false) {
        const masterNode = bip32.fromSeed(seed);
        const node = masterNode.derivePath(derivationPath);
        if (node.privateKey === undefined) {
            return undefined;
        }
        const publicKey = utils_1.default.hexFromBuffer(node.publicKey);
        const privateKey = utils_1.default.hexFromBuffer(node.privateKey);
        return new Wallet(publicKey, `00${privateKey}`, test);
    }
    /**
     * Generate a new wallet from the given seed.
     *
     * @deprecated Please use `WalletFactory` instead.
     *
     * @param seed - The given seed for the wallet.
     * @param test - Whether the address is for use on a test network, defaults to `false`.
     * @returns A new wallet from the given seed, or undefined if the seed was invalid.
     */
    static generateWalletFromSeed(seed, test = false) {
        try {
            const keyPair = rippleKeyPair.deriveKeypair(seed);
            return new Wallet(keyPair.publicKey, keyPair.privateKey, test);
        }
        catch (_a) {
            return undefined;
        }
    }
    /**
     * Gets the x-address associated with a given wallet instance.
     *
     * @returns A string representing the x-address of the wallet.
     *
     * @throws An error if we are unable to derive an address.
     */
    getAddress() {
        const classicAddress = rippleKeyPair.deriveAddress(this.publicKey);
        const xAddress = xrp_utils_1.default.encodeXAddress(classicAddress, undefined, this.test);
        if (xAddress === undefined) {
            throw new Error('Unknown error deriving address');
        }
        return xAddress;
    }
    /**
     * Sign an arbitrary hex string.
     *
     * @param hex - An arbitrary hex string to sign.
     * @returns A signature in hexadecimal format if the input was valid, otherwise undefined.
     */
    sign(hex) {
        if (!utils_1.default.isHex(hex)) {
            return undefined;
        }
        return rippleKeyPair.sign(hex, this.privateKey);
    }
    /**
     * Verify a signature is valid for a message.
     *
     * @param message - A message in hex format.
     * @param signature - A signature in hex format.
     * @returns True if the signature is valid, otherwise false.
     */
    verify(message, signature) {
        if (!utils_1.default.isHex(signature) || !utils_1.default.isHex(message)) {
            return false;
        }
        try {
            return rippleKeyPair.verify(message, signature, this.publicKey);
        }
        catch (_a) {
            // The ripple-key-pair module may throw errors for some signatures rather than returning false.
            // If an error was thrown then the signature is definitely not valid.
            return false;
        }
    }
}
/**
 * The default derivation path to use with BIP44.
 */
Wallet.defaultDerivationPath = "m/44'/144'/0'/0/0";
exports.default = Wallet;
//# sourceMappingURL=wallet.js.map