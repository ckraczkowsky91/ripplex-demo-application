"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bip32 = __importStar(require("bip32"));
const bip39 = __importStar(require("bip39"));
const rippleKeyPair = __importStar(require("ripple-keypairs"));
const utils_1 = __importDefault(require("../Common/utils"));
const hd_wallet_generation_result_1 = __importDefault(require("./hd-wallet-generation-result"));
const seed_wallet_generation_result_1 = __importDefault(require("./seed-wallet-generation-result"));
const wallet_1 = __importDefault(require("./wallet"));
const xrp_utils_1 = __importDefault(require("./xrp-utils"));
/**
 * Encapsulates various methods for generating Wallets.
 */
class WalletFactory {
    /**
     * Initialize a new WalletFactory.
     *
     * @param network - The network the wallet factory is attached to.
     */
    constructor(network) {
        this.network = network;
        this.isTest = xrp_utils_1.default.isTestNetwork(network);
    }
    /**
     * Generate a new HD wallet with a random mnemonic and the default XRP derivation path.
     *
     * Secure random number generation is used when entropy is omitted and when the runtime environment has the necessary support.
     * Otherwise, an error is thrown.
     *
     * Runtime environments that do not have secure random number generation should pass their own buffer of entropy.
     *
     * @param entropy - An optional hex string of entropy.
     * @returns A result which contains the newly generated wallet and associated artifacts.
     */
    async generateRandomHdWallet(entropy = undefined) {
        if (entropy && !utils_1.default.isHex(entropy)) {
            return undefined;
        }
        const mnemonic = entropy === undefined
            ? bip39.generateMnemonic()
            : bip39.entropyToMnemonic(entropy);
        const derivationPath = WalletFactory.defaultDerivationPath;
        const wallet = await this.walletFromMnemonicAndDerivationPath(mnemonic, derivationPath);
        return wallet === undefined
            ? undefined
            : new hd_wallet_generation_result_1.default(mnemonic, derivationPath, wallet);
    }
    /**
     * Generate a new wallet with a random seed.
     *
     * Secure random number generation is used when entropy is omitted and when the runtime environment has the necessary support.
     * Otherwise, an error is thrown.
     *
     * Runtime environments that do not have secure random number generation should pass their own buffer of entropy.
     *
     * @param entropy - A optional hex string of entropy.
     * @returns A result which contains the newly generated wallet and associated artifacts.
     */
    async generateRandomWallet(entropy = undefined) {
        if (entropy && !utils_1.default.isHex(entropy)) {
            return undefined;
        }
        const generationParameters = entropy === undefined ? {} : { entropy: utils_1.default.toBytes(entropy) };
        const seed = rippleKeyPair.generateSeed(generationParameters);
        const wallet = this.walletFromSeed(seed);
        return wallet === undefined
            ? undefined
            : new seed_wallet_generation_result_1.default(seed, wallet);
    }
    /**
     * Generate a new hierarchical deterministic wallet from a mnemonic and derivation path.
     *
     * @param mnemonic - The mnemonic to generate the wallet.
     * @param derivationPath - The given derivation path to use. If undefined, the default path is used.
     * @returns A new wallet from the given mnemonic if the mnemonic was valid, otherwise undefined.
     */
    async walletFromMnemonicAndDerivationPath(mnemonic, derivationPath = WalletFactory.defaultDerivationPath) {
        // Validate mnemonic and path are valid.
        if (!bip39.validateMnemonic(mnemonic)) {
            return undefined;
        }
        const seed = await bip39.mnemonicToSeed(mnemonic);
        return wallet_1.default.generateHDWalletFromSeed(seed, derivationPath, this.isTest);
    }
    /**
     * Generate a new hierarchical deterministic wallet from a seed and derivation path.
     *
     * @param seed - A hex encoded seed string.
     * @param derivationPath - The given derivation path to use. If undefined, the default path is used.
     * @returns A new wallet from the given seed if the seed was valid, otherwise undefined.
     */
    // eslint-disable-next-line max-statements -- This does not read as too complex a function.
    walletFromSeedAndDerivationPath(seed, derivationPath = WalletFactory.defaultDerivationPath) {
        try {
            const seedBytes = utils_1.default.toBytes(seed);
            const seedBuffer = Buffer.from(seedBytes);
            const masterNode = bip32.fromSeed(seedBuffer);
            const node = masterNode.derivePath(derivationPath);
            if (node.privateKey === undefined) {
                return undefined;
            }
            const publicKey = utils_1.default.hexFromBuffer(node.publicKey);
            const privateKey = utils_1.default.hexFromBuffer(node.privateKey);
            // Add a 1 byte prefix to indicate that this is a secp256k1 key.
            // See: https://xrpl.org/cryptographic-keys.html#ed25519-key-derivation.
            const prefixedPrivateKey = `00${privateKey}`;
            return new wallet_1.default(publicKey, prefixedPrivateKey, this.isTest);
        }
        catch (error) {
            console.log(error);
            return undefined;
        }
    }
    /**
     * Generate a new wallet from the given seed.
     *
     * @param seed - A base58check encoded seed string.
     * @returns A new wallet from the given seed, or undefined if the seed was invalid.
     */
    walletFromSeed(seed) {
        try {
            const keyPair = rippleKeyPair.deriveKeypair(seed);
            return new wallet_1.default(keyPair.publicKey, keyPair.privateKey, this.isTest);
        }
        catch (_a) {
            return undefined;
        }
    }
    /**
     * Generate a new wallet with the given keys.
     *
     * @param publicKey - A hexadecimal encoded public key.
     * @param privateKey -  A hexadecimal encoded private key.
     *
     * @returns A new wallet with a given public and private key,
     *          on TESTNET or MAINNET depending on the WalletFactory instance.
     */
    walletFromKeys(publicKey, privateKey) {
        if (!utils_1.default.isHex(publicKey) || !utils_1.default.isHex(privateKey)) {
            return undefined;
        }
        return new wallet_1.default(publicKey, privateKey, this.isTest);
    }
}
exports.default = WalletFactory;
/**
 * The default derivation path to use with BIP44.
 */
WalletFactory.defaultDerivationPath = "m/44'/144'/0'/0/0";
//# sourceMappingURL=wallet-factory.js.map