"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
const shared_1 = require("../shared");
const rippled_web_socket_schema_1 = require("../shared/rippled-web-socket-schema");
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
/**
 * A network client for interacting with the rippled WebSocket API.
 * @see https://xrpl.org/rippled-api.html
 */
class WebSocketNetworkClient {
    /**
     * Create a new WebSocketNetworkClient.
     *
     * @param webSocketUrl The URL of the rippled node to query.
     * @see https://xrpl.org/monitor-incoming-payments-with-websocket.html
     */
    constructor(webSocketUrl, handleErrorMessage) {
        this.handleErrorMessage = handleErrorMessage;
        this.accountCallbacks = new Map();
        this.messageCallbacks = new Map();
        this.waiting = new Map();
        this.idNumber = 0; // added to web socket request IDs to ensure unique IDs
        this.socket = new isomorphic_ws_1.default(webSocketUrl);
        this.messageCallbacks.set('response', (data) => {
            const dataStatusResponse = data;
            this.waiting.set(dataStatusResponse.id, data);
        });
        this.messageCallbacks.set('transaction', (data) => this.handleTransaction(data));
        this.socket.addEventListener('message', (event) => {
            const parsedData = JSON.parse(event.data);
            const messageType = parsedData.type;
            const callback = this.messageCallbacks.get(messageType);
            if (callback) {
                callback(parsedData);
            }
            else {
                this.handleErrorMessage(`Received unhandlable message: ${event.data}`);
            }
        });
        this.socket.addEventListener('close', (event) => {
            this.handleErrorMessage(`WebSocket disconnected, ${event.reason}`);
        });
        this.socket.addEventListener('error', (event) => {
            this.handleErrorMessage(`WebSocket error: ${event.message}`);
        });
    }
    /**
     * Properly handles incoming transactions from the websocket.
     *
     * @param data The websocket response received from the websocket.
     */
    handleTransaction(data) {
        const destinationAccount = data.transaction.Destination;
        const destinationCallback = this.accountCallbacks.get(destinationAccount);
        const senderAccount = data.transaction.Account;
        const senderCallback = this.accountCallbacks.get(senderAccount);
        if (destinationCallback) {
            destinationCallback(data);
        }
        if (senderCallback) {
            senderCallback(data);
        }
        if (!destinationCallback && !senderCallback) {
            throw new shared_1.XrpError(shared_1.XrpErrorType.Unknown, `Received a transaction for an account that has not been subscribed to: ${destinationAccount}`);
        }
    }
    /**
     * Sends an API request over the websocket connection.
     * @see https://xrpl.org/monitor-incoming-payments-with-websocket.html
     *
     * @param request The object to send over the websocket.
     * @returns The API response from the websocket.
     */
    async sendApiRequest(request) {
        while (this.socket.readyState === rippled_web_socket_schema_1.WebSocketReadyState.Connecting) {
            await sleep(5);
        }
        if (this.socket.readyState !== rippled_web_socket_schema_1.WebSocketReadyState.Open) {
            throw new shared_1.XrpError(shared_1.XrpErrorType.Unknown, 'Socket is closed/closing');
        }
        this.socket.send(JSON.stringify(request));
        this.waiting.set(request.id, undefined);
        let response = this.waiting.get(request.id);
        while (response === undefined) {
            await sleep(5);
            response = this.waiting.get(request.id);
        }
        this.waiting.delete(request.id);
        return response;
    }
    /**
     * Subscribes for notification about every validated transaction that affects the given account.
     * @see https://xrpl.org/subscribe.html
     *
     * @param account The account from which to subscribe to incoming transactions, encoded as a classic address.
     * @param callback The function called whenever a new transaction is received.
     * @returns The response from the websocket confirming the subscription.
     */
    async subscribeToAccount(account, callback) {
        const subscribeRequest = {
            id: `monitor_transactions_${account}_${this.idNumber}`,
            command: rippled_web_socket_schema_1.RippledMethod.subscribe,
            accounts: [account],
        };
        this.idNumber++;
        const response = await this.sendApiRequest(subscribeRequest);
        if (response.status !== rippled_web_socket_schema_1.ResponseStatus.success) {
            const errorResponse = response;
            throw new shared_1.XrpError(shared_1.XrpErrorType.Unknown, `Subscription request for ${account} failed, ${errorResponse.error_message}`);
        }
        this.accountCallbacks.set(account, callback);
        return response;
    }
    /**
     * Unsubscribes from notifications about every validated transaction that affects the given account.
     * @see https://xrpl.org/unsubscribe.html
     *
     * @param account The account from which to unsubscribe from incoming transactions, encoded as a classic address.
     * @returns The response from the websocket confirming the unsubscription.
     */
    async unsubscribeFromAccount(account) {
        if (!this.accountCallbacks.has(account)) {
            throw new shared_1.XrpError(shared_1.XrpErrorType.InvalidInput, `Not currently subscribed to ${account}, do not need to unsubscribe`);
        }
        const unsubscribeRequest = {
            id: `unsubscribe_transactions_${account}_${this.idNumber}`,
            command: rippled_web_socket_schema_1.RippledMethod.unsubscribe,
            accounts: [account],
        };
        this.idNumber++;
        const response = await this.sendApiRequest(unsubscribeRequest);
        if (response.status !== rippled_web_socket_schema_1.ResponseStatus.success) {
            const errorResponse = response;
            throw new shared_1.XrpError(shared_1.XrpErrorType.Unknown, `Unsubscribe request for ${account} failed, ${errorResponse.error_message}`);
        }
        this.accountCallbacks.delete(account);
        return response;
    }
    /**
     * Submits an account_lines request to the rippled WebSocket API.
     * @see https://xrpl.org/account_lines.html
     *
     * @param account The XRPL account to query for trust lines.
     */
    async getAccountLines(account, peerAccount) {
        const accountLinesRequest = {
            id: `${rippled_web_socket_schema_1.RippledMethod.accountLines}_${account}_${this.idNumber}`,
            command: rippled_web_socket_schema_1.RippledMethod.accountLines,
            account,
            ledger_index: 'validated',
            peer: peerAccount,
        };
        this.idNumber++;
        return (await this.sendApiRequest(accountLinesRequest));
    }
    /**
     * Submits a gateway_balances request to the rippled WebSocket API.
     * @see https://xrpl.org/gateway_balances.html
     *
     * @param account The XRPL account for which to retrieve issued currency balances.
     * @param addressesToExclude (Optional) An array of operational address to exclude from the balances issued.
     * @see https://xrpl.org/issuing-and-operational-addresses.html
     */
    async getGatewayBalances(account, addressesToExclude) {
        const gatewayBalancesRequest = {
            id: `${rippled_web_socket_schema_1.RippledMethod.gatewayBalances}_${account}_${this.idNumber}`,
            command: rippled_web_socket_schema_1.RippledMethod.gatewayBalances,
            account,
            strict: true,
            hotwallet: addressesToExclude,
            ledger_index: 'validated',
        };
        this.idNumber++;
        const gatewayBalancesResponse = await this.sendApiRequest(gatewayBalancesRequest);
        return gatewayBalancesResponse;
    }
    /**
     * Submits an account_offers request to the rippled WebSocket API.
     * @see https://xrpl.org/account_offers.html
     *
     * @param account The XRPL account for which to retrieve a list of outstanding offers.
     */
    async getAccountOffers(account) {
        const accountOffersRequest = {
            id: `${rippled_web_socket_schema_1.RippledMethod.accountOffers}_${account}_${this.idNumber}`,
            command: rippled_web_socket_schema_1.RippledMethod.accountOffers,
            account,
        };
        this.idNumber++;
        const accountOffersResponse = await this.sendApiRequest(accountOffersRequest);
        return accountOffersResponse;
    }
    /**
     * Submits a ripple_path_find request to the rippled WebSocket API.
     * @see https://xrpl.org/ripple_path_find.html
     *
     * @param sourceAccount The XRPL account at the start of the desired path, as a classic address.
     * @param destinationAccount The XRPL account at the end of the desired path, as a classic address.
     * @param destinationAmount The currency amount that the destination account would receive in a transaction
     *                          (-1 if the path should deliver as much as possible).
     * @param sendMax The currency amount that would be spent in the transaction (cannot be used with sourceCurrencies).
     * @param sourceCurrencies An array of currencies that the source account might want to spend (cannot be used with sendMax).
     */
    async findRipplePath(sourceAccount, destinationAccount, destinationAmount, sendMax, sourceCurrencies) {
        if (sendMax && sourceCurrencies) {
            throw new shared_1.XrpError(shared_1.XrpErrorType.InvalidInput, 'Cannot provide values for both `sendMax` and `sourceCurrencies`');
        }
        const ripplePathFindRequest = {
            id: `${rippled_web_socket_schema_1.RippledMethod.ripplePathFind}_${sourceAccount}_${this.idNumber}`,
            command: rippled_web_socket_schema_1.RippledMethod.ripplePathFind,
            source_account: sourceAccount,
            destination_account: destinationAccount,
            destination_amount: destinationAmount,
            send_max: sendMax,
            source_currencies: sourceCurrencies,
        };
        this.idNumber++;
        const ripplePathFindResponse = await this.sendApiRequest(ripplePathFindRequest);
        return ripplePathFindResponse;
    }
    /**
     * Closes the socket.
     */
    close() {
        this.socket.close();
    }
}
exports.default = WebSocketNetworkClient;
//# sourceMappingURL=web-socket-network-client.js.map