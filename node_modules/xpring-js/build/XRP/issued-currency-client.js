"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_pb_1 = require("./Generated/web/org/xrpl/rpc/v1/common_pb");
const account_pb_1 = require("./Generated/web/org/xrpl/rpc/v1/account_pb");
const amount_pb_1 = require("./Generated/web/org/xrpl/rpc/v1/amount_pb");
const transaction_pb_1 = require("./Generated/web/org/xrpl/rpc/v1/transaction_pb");
const utils_1 = __importDefault(require("../Common/utils"));
const core_xrpl_client_1 = __importDefault(require("./core-xrpl-client"));
const grpc_xrp_network_client_1 = __importDefault(require("./network-clients/grpc-xrp-network-client"));
const grpc_xrp_network_client_web_1 = __importDefault(require("./network-clients/grpc-xrp-network-client.web"));
const shared_1 = require("./shared");
const account_set_flag_1 = require("./shared/account-set-flag");
const gateway_balances_1 = require("./shared/gateway-balances");
const trustline_1 = __importDefault(require("./shared/trustline"));
const rippled_web_socket_schema_1 = require("./shared/rippled-web-socket-schema");
const web_socket_network_client_1 = __importDefault(require("./network-clients/web-socket-network-client"));
const common_pb_2 = require("xpring-common-js/build/src/XRP/generated/org/xrpl/rpc/v1/common_pb");
const rippled_error_messages_1 = require("./shared/rippled-error-messages");
const trust_set_flag_1 = __importDefault(require("./shared/trust-set-flag"));
const bignumber_js_1 = require("bignumber.js");
const transaction_pb_2 = require("xpring-common-js/build/src/XRP/generated/org/xrpl/rpc/v1/transaction_pb");
const xrp_utils_1 = __importDefault(require("./shared/xrp-utils"));
const offer_create_flag_1 = __importDefault(require("./shared/offer-create-flag"));
/**
 * IssuedCurrencyClient is a client for working with Issued Currencies on the XRPL.
 * @see https://xrpl.org/issued-currencies-overview.html
 */
class IssuedCurrencyClient {
    /**
     * Create a new IssuedCurrencyClient with a custom network client implementation.
     *
     * In general, clients should prefer to call `issuedCurrencyClientWithEndpoint`. This constructor is provided to improve testability of this class.
     *
     * @param networkClient A network client which will manage remote RPCs to Rippled.
     * @param network The network this IssuedCurrencyClient is connecting to.
     */
    constructor(grpcNetworkClient, webSocketNetworkClient, network) {
        this.webSocketNetworkClient = webSocketNetworkClient;
        this.network = network;
        this.coreXrplClient = new core_xrpl_client_1.default(grpcNetworkClient, network);
    }
    /**
     * Create a new IssuedCurrencyClient.
     *
     * The IssuedCurrencyClient will use gRPC to communicate with the given endpoint.
     *
     * @param grpcUrl The URL of the gRPC instance to connect to.
     * @param network The network this IssuedCurrencyClient is connecting to.
     * @param forceWeb If `true`, then we will use the gRPC-Web client even when on Node. Defaults to false. This is mainly for testing and in the future will be removed when we have browser testing.
     */
    static issuedCurrencyClientWithEndpoint(grpcUrl, webSocketUrl, handleWebSocketErrorMessage, network, forceWeb = false) {
        const grpcNetworkClient = utils_1.default() && !forceWeb
            ? new grpc_xrp_network_client_1.default(grpcUrl)
            : new grpc_xrp_network_client_web_1.default(grpcUrl);
        return new IssuedCurrencyClient(grpcNetworkClient, new web_socket_network_client_1.default(webSocketUrl, handleWebSocketErrorMessage), network);
    }
    /**
     * Retrieves information about an account's trust lines, which maintain balances of all non-XRP currencies and assets.
     * @see https://xrpl.org/trust-lines-and-issuing.html
     *
     * @param account The account for which to retrieve associated trust lines, encoded as an X-Address.
     * @param peerAccount (Optional) The address of a second account, encoded as an X-Address.
     *                    If provided, show only trust lines connecting the two accounts.
     * @see https://xrpaddress.info/
     * @returns An array of TrustLine objects, representing all trust lines associated with this account.
     */
    async getTrustLines(account, peerAccount) {
        const classicAddress = xrp_utils_1.default.decodeXAddress(account);
        if (!classicAddress) {
            throw shared_1.XrpError.xAddressRequired;
        }
        if (peerAccount) {
            const peerClassicAddress = xrp_utils_1.default.decodeXAddress(peerAccount);
            if (!peerClassicAddress) {
                throw shared_1.XrpError.xAddressRequired;
            }
        }
        const accountLinesResponse = await this.webSocketNetworkClient.getAccountLines(classicAddress.address, peerAccount);
        const error = accountLinesResponse.error;
        if (error) {
            if (error === rippled_error_messages_1.RippledErrorMessages.accountNotFound) {
                throw shared_1.XrpError.accountNotFound;
            }
            else {
                throw new shared_1.XrpError(shared_1.XrpErrorType.Unknown, error);
            }
        }
        const accountLinesSuccessfulResponse = accountLinesResponse;
        const rawTrustLines = accountLinesSuccessfulResponse.result.lines;
        if (rawTrustLines === undefined) {
            throw shared_1.XrpError.malformedResponse;
        }
        const trustLines = [];
        rawTrustLines.map((trustline) => {
            trustLines.push(new trustline_1.default(trustline));
        });
        return trustLines;
    }
    /**
     * Returns information about the total balances issued by a given account,
     * optionally excluding amounts held by operational addresses.
     * @see https://xrpl.org/issuing-and-operational-addresses.html
     *
     * @param account The account for which to retrieve balance information, encoded as an X-Address.
     * @param accountsToExclude (Optional) An array of operational addresses to exclude from the balances issued, encoded as X-Addresses.
     * @see https://xrpaddress.info/
     * @returns A GatewayBalances object containing information about an account's balances.
     */
    async getGatewayBalances(account, accountsToExclude = []) {
        // check issuing account for X-Address format
        const classicAddress = xrp_utils_1.default.decodeXAddress(account);
        if (!classicAddress) {
            throw shared_1.XrpError.xAddressRequired;
        }
        // check excludable addresses for X-Address format, and convert to classic addresses for request
        const classicAddressesToExclude = accountsToExclude.map((xAddress) => {
            const excludeClassicAddress = xrp_utils_1.default.decodeXAddress(xAddress);
            if (!excludeClassicAddress) {
                throw shared_1.XrpError.xAddressRequired;
            }
            return classicAddress.address;
        });
        const gatewayBalancesResponse = await this.webSocketNetworkClient.getGatewayBalances(classicAddress.address, classicAddressesToExclude);
        const error = gatewayBalancesResponse.error;
        if (!error) {
            return gateway_balances_1.gatewayBalancesFromResponse(gatewayBalancesResponse);
        }
        switch (error) {
            case rippled_error_messages_1.RippledErrorMessages.accountNotFound:
                throw shared_1.XrpError.accountNotFound;
            case rippled_error_messages_1.RippledErrorMessages.invalidExcludedAddress:
                throw new shared_1.XrpError(shared_1.XrpErrorType.InvalidInput, 'The address(es) supplied to for exclusion were invalid.');
            default:
                throw new shared_1.XrpError(shared_1.XrpErrorType.Unknown, error);
        }
    }
    /**
     * Subscribes to all transactions that affect the specified account, and triggers a callback upon
     * receiving each transaction.
     * @see https://xrpl.org/monitor-incoming-payments-with-websocket.html
     * @see https://xrpl.org/subscribe.html
     *
     * @param account The account for which to subscribe to relevant transactions, encoded as an X-Address.
     * @param callback The function to trigger upon receiving a transaction event from the ledger.
     * @returns Whether the request to subscribe succeeded.
     */
    async monitorAccountTransactions(account, callback) {
        const classicAddress = xrp_utils_1.default.decodeXAddress(account);
        if (!classicAddress) {
            throw shared_1.XrpError.xAddressRequired;
        }
        const response = await this.webSocketNetworkClient.subscribeToAccount(classicAddress.address, callback);
        return response.status === rippled_web_socket_schema_1.ResponseStatus.success;
    }
    /**
     * Unsubscribes from transactions that affect the specified account.
     * @see https://xrpl.org/unsubscribe.html
     *
     * @param account The account from which to unsubscribe from, encoded as an X-Address.
     * @returns Whether the request to unsubscribe succeeded.
     */
    async stopMonitoringAccountTransactions(account) {
        const classicAddress = xrp_utils_1.default.decodeXAddress(account);
        if (!classicAddress) {
            throw shared_1.XrpError.xAddressRequired;
        }
        const response = await this.webSocketNetworkClient.unsubscribeFromAccount(classicAddress.address);
        return response.status === rippled_web_socket_schema_1.ResponseStatus.success;
    }
    /**
     * Enable Require Authorization for this XRPL account.
     *
     * @see https://xrpl.org/become-an-xrp-ledger-gateway.html#require-auth
     *
     * @param wallet The wallet associated with the XRPL account enabling Require Authorization and that will sign the request.
     * @returns A promise which resolves to a TransactionResult object that represents the result of this transaction.
     */
    async requireAuthorizedTrustlines(wallet) {
        return this.coreXrplClient.changeFlag(account_set_flag_1.AccountSetFlag.asfRequireAuth, true, wallet);
    }
    /**
     * Disable Require Authorization for this XRPL account.
     *
     * @see https://xrpl.org/become-an-xrp-ledger-gateway.html#require-auth
     *
     * @param wallet The wallet associated with the XRPL account disabling Require Authorization and that will sign the request.
     * @returns A promise which resolves to a TransactionResult object that represents the result of this transaction.
     */
    async allowUnauthorizedTrustlines(wallet) {
        return this.coreXrplClient.changeFlag(account_set_flag_1.AccountSetFlag.asfRequireAuth, false, wallet);
    }
    /**
     * Enable Default Ripple for this XRPL account.
     *
     * @see https://xrpl.org/become-an-xrp-ledger-gateway.html#default-ripple
     *
     * @param wallet The wallet associated with the XRPL account enabling Default Ripple and that will sign the request.
     * @returns A promise which resolves to a TransactionResult object that represents the result of this transaction.
     */
    async enableRippling(wallet) {
        return this.coreXrplClient.changeFlag(account_set_flag_1.AccountSetFlag.asfDefaultRipple, true, wallet);
    }
    /**
     * Enable Disallow XRP for this XRPL account.
     * Note that the meaning of this flag is not enforced by rippled, and is only intended for use by client applications.
     *
     * @see https://xrpl.org/become-an-xrp-ledger-gateway.html#disallow-xrp
     *
     * @param wallet The wallet associated with the XRPL account enabling Disallow XRP and that will sign the request.
     * @returns A promise which resolves to a TransactionResult object that represents the result of this transaction.
     */
    async disallowIncomingXrp(wallet) {
        return this.coreXrplClient.changeFlag(account_set_flag_1.AccountSetFlag.asfDisallowXRP, true, wallet);
    }
    /**
     * Disable Disallow XRP for this XRPL account.
     * Note that the meaning of this flag is not enforced by rippled, and is only intended for use by client applications.
     *
     * @see https://xrpl.org/become-an-xrp-ledger-gateway.html#disallow-xrp
     *
     * @param wallet The wallet associated with the XRPL account disabling Disallow XRP and that will sign the request.
     * @returns A promise which resolves to a TransactionResult object that represents the result of this transaction.
     */
    async allowIncomingXrp(wallet) {
        return this.coreXrplClient.changeFlag(account_set_flag_1.AccountSetFlag.asfDisallowXRP, false, wallet);
    }
    /**
     * Enable Require Destination Tags for this XRPL account.
     *
     * @see https://xrpl.org/require-destination-tags.html
     *
     * @param wallet The wallet associated with the XRPL account enabling Require Destination Tags and that will sign the request.
     * @returns A promise which resolves to a TransactionResult object that represents the result of this transaction.
     */
    async requireDestinationTags(wallet) {
        return this.coreXrplClient.changeFlag(account_set_flag_1.AccountSetFlag.asfRequireDest, true, wallet);
    }
    /**
     * Disable Require Destination for this XRPL account.
     *
     * @see https://xrpl.org/require-destination-tags.html
     *
     * @param wallet The wallet associated with the XRPL account disabling Require Destination and that will sign the request.
     * @returns A promise which resolves to a TransactionResult object that represents the result of this transaction.
     */
    async allowNoDestinationTag(wallet) {
        return this.coreXrplClient.changeFlag(account_set_flag_1.AccountSetFlag.asfRequireDest, false, wallet);
    }
    /**
     * Get the Transfer Fees for a given issuing account.
     * The Transfer Fee is a percentage to charge when two users transfer an issuer's IOUs on the XRPL.
     *
     * @see https://xrpl.org/transfer-fees.html
     *
     * @param address The X-address for which the transfer rate is requested.
     * @returns A promise which resolves to a number that represents the transfer fee associated with that issuing account,
     *          or undefined if one is not specified.
     */
    async getTransferFee(address) {
        var _a;
        const classicAddress = xrp_utils_1.default.decodeXAddress(address);
        if (!classicAddress) {
            throw shared_1.XrpError.xAddressRequired;
        }
        const accountRoot = await this.coreXrplClient.getAccountData(classicAddress.address);
        return (_a = accountRoot.getTransferRate()) === null || _a === void 0 ? void 0 : _a.getValue();
    }
    /**
     * Set the Transfer Fees for an issuing account.
     * The Transfer Fee is a percentage to charge when two users transfer an issuer's IOUs on the XRPL.
     *
     * @see https://xrpl.org/transfer-fees.html
     *
     * @param transferFee The amount you must send for the recipient to get 1 billion units of the same currency.
     *                    It cannot be set to less than 1000000000 or more than 2000000000.
     * @param wallet The wallet associated with the issuing account, and that will sign the request.
     * @returns A promise which resolves to a TransactionResult object that represents the result of this transaction.
     */
    async setTransferFee(transferFee, wallet) {
        const transferRate = new common_pb_1.TransferRate();
        transferRate.setValue(transferFee);
        const accountSet = new transaction_pb_1.AccountSet();
        accountSet.setTransferRate(transferRate);
        const transaction = await this.coreXrplClient.prepareBaseTransaction(wallet);
        transaction.setAccountSet(accountSet);
        const transactionHash = await this.coreXrplClient.signAndSubmitTransaction(transaction, wallet);
        return this.coreXrplClient.getFinalTransactionResultAsync(transactionHash, wallet);
    }
    /**
     * Enable Global Freeze for this XRPL account.
     *
     * @see https://xrpl.org/freezes.html#global-freeze
     *
     * @param wallet The wallet associated with the XRPL account enabling Global Freeze and that will sign the request.
     * @returns A promise which resolves to a TransactionResult object that represents the result of this transaction.
     */
    async enableGlobalFreeze(wallet) {
        return this.coreXrplClient.changeFlag(account_set_flag_1.AccountSetFlag.asfGlobalFreeze, true, wallet);
    }
    /**
     * Disable Global Freeze for this XRPL account.
     *
     * @see https://xrpl.org/freezes.html#global-freeze
     *
     * @param wallet The wallet associated with the XRPL account disabling Global Freeze and that will sign the request.
     * @returns A promise which resolves to a TransactionResult object that represents the result of this transaction.
     */
    async disableGlobalFreeze(wallet) {
        return this.coreXrplClient.changeFlag(account_set_flag_1.AccountSetFlag.asfGlobalFreeze, false, wallet);
    }
    /**
     * Permanently enable No Freeze for this XRPL account.
     *
     * @see https://xrpl.org/freezes.html#no-freeze
     *
     * @param wallet The wallet associated with the XRPL account enabling No Freeze and that will sign the request.
     * @returns A promise which resolves to a TransactionResult object that represents the result of this transaction.
     */
    async enableNoFreeze(wallet) {
        return this.coreXrplClient.changeFlag(account_set_flag_1.AccountSetFlag.asfNoFreeze, true, wallet);
    }
    /**
     * Creates a trust line between this XRPL account and an issuer of an IssuedCurrency.
     *
     * @see https://xrpl.org/trustset.html
     *
     * @param issuerXAddress The X-Address of the issuer to extend trust to.
     * @param currencyName The currency this trust line applies to, as a three-letter ISO 4217 Currency Code  or a 160-bit hex value according to currency format.
     * @param amount Decimal representation of the limit to set on this trust line.
     * @param wallet The wallet creating the trustline.
     * @param qualityIn (Optional) Value incoming balances on this trust line at the ratio of this number per 1,000,000,000 units.
     *                  A value of 0 is shorthand for treating balances at face value.
     * @param qualityOut (Optional) Value outgoing balances on this trust line at the ratio of this number per 1,000,000,000 units.
     *                  A value of 0 is shorthand for treating balances at face value.
     */
    async createTrustLine(issuerXAddress, currencyName, amount, wallet, qualityIn, qualityOut) {
        return this.sendTrustSetTransaction(issuerXAddress, currencyName, amount, undefined, wallet, qualityIn, qualityOut);
    }
    /**
     * Creates an authorized trust line between this XRPL account (issuing account) and another account.
     * Note that the other account must also create a trust line to this issuing account in order to establish a trust line with a non-zero limit.
     * If this method is called before the other account creates a trust line, a trust line with a limit of 0 is created.
     * However, this is only true if this issuing account has already required Authorized Trustlines (see https://xrpl.org/authorized-trust-lines.html),
     * otherwise no trust line is created.
     *
     * @see https://xrpl.org/authorized-trust-lines.html
     *
     * @param accountToAuthorize The X-Address of the address with which to authorize a trust line.
     * @param currencyName The currency to authorize a trust line for.
     * @param wallet The wallet creating the authorized trust line.
     */
    async authorizeTrustLine(accountToAuthorize, currencyName, wallet) {
        // When authorizing a trust line, the value of the trust line is set to 0.
        // See https://xrpl.org/authorized-trust-lines.html#authorizing-trust-lines
        return this.sendTrustSetTransaction(accountToAuthorize, currencyName, '0', trust_set_flag_1.default.tfSetfAuth, wallet);
    }
    /**
     * Freezes the trust line between this account (issuing account) and another account.
     * Note that the trust line's limit is set to 0.
     *
     * @see https://xrpl.org/freezes.html#enabling-or-disabling-individual-freeze
     *
     * @param trustLinePeerAccount The X-Address of the account involved in the trust line being frozen.
     * @param currencyName The currency of the trust line to freeze.
     * @param wallet The wallet freezing the trust line.
     */
    async freezeTrustLine(trustLinePeerAccount, currencyName, wallet) {
        return this.sendTrustSetTransaction(trustLinePeerAccount, currencyName, 
        // You can change the trust line when you freeze it, but an amount of 0
        // would be the most conservative amount.
        '0', trust_set_flag_1.default.tfSetFreeze, wallet);
    }
    /**
     * Unfreezes the trust line between this account (issuing account) and another account.
     * Note that the trust line's limit is set to 0.
     *
     * @see https://xrpl.org/freezes.html#enabling-or-disabling-individual-freeze
     *
     * @param trustLinePeerAccount The X-Address of the account involved in the trust line being unfrozen.
     * @param currencyName The currency of the trust line to unfreeze.
     * @param wallet The wallet unfreezing the trust line.
     */
    async unfreezeTrustLine(trustLinePeerAccount, currencyName, wallet) {
        return this.sendTrustSetTransaction(trustLinePeerAccount, currencyName, 
        // You can change the trust line amount when you unfreeze it, but this would typically
        // be used by gateways, who will maintain an amount of 0.
        '0', trust_set_flag_1.default.tfClearFreeze, wallet);
    }
    /**
     * Disables rippling on the trust line between this account (issuing account) and another account.
     *
     * @see https://xrpl.org/rippling.html#enabling-disabling-no-ripple
     *
     * @param trustLinePeerAccount The X-Address of the account involved in the trust line being disabled to ripple.
     * @param currencyName The currency of the trust line being disbaled to ripple.
     * @param amount The maximum amount of debt to allow on this trust line.
     * @param wallet The wallet disabling rippling on the trust line.
     */
    async disableRipplingForTrustLine(trustLinePeerAccount, currencyName, amount, wallet) {
        return this.sendTrustSetTransaction(trustLinePeerAccount, currencyName, amount, trust_set_flag_1.default.tfSetNoRipple, wallet);
    }
    /**
     * Re-enables rippling on the trust line between this account (issuing account) and another account.
     *
     * @see https://xrpl.org/rippling.html#enabling-disabling-no-ripple
     *
     * @param trustLinePeerAccount trustLinePeerAccount The X-Address of the account involved in the trust line being re-enabled to ripple.
     * @param currencyName The currency of the trust line being re-enabled to ripple.
     * @param amount The maximum amount of debt to allow on this trust line.
     * @param wallet The wallet re-enabling rippling on the trust line.
     */
    async enableRipplingForTrustLine(trustLinePeerAccount, currencyName, amount, wallet) {
        return this.sendTrustSetTransaction(trustLinePeerAccount, currencyName, amount, trust_set_flag_1.default.tfClearNoRipple, wallet);
    }
    /*
     * Creates and sends a TrustSet transaction to the XRPL.
     *
     * @param accountToTrust The account to extend trust to with a trust line.
     * @param currencyName The name of the currency to create a trust line for.
     * @param amount The maximum amount of debt to allow on this trust line.
     * @param wallet A wallet associated with the account extending trust.
     * @param qualityIn (Optional) Value incoming balances on this trust line at the ratio of this number per 1,000,000,000 units.
     *                  A value of 0 is shorthand for treating balances at face value.
     * @param qualityOut (Optional) Value outgoing balances on this trust line at the ratio of this number per 1,000,000,000 units.
     *                  A value of 0 is shorthand for treating balances at face value.
     */
    async sendTrustSetTransaction(accountToTrust, currencyName, amount, flags, wallet, qualityIn, qualityOut) {
        const trustSetTransaction = await this.prepareTrustSetTransaction(accountToTrust, currencyName, amount, flags, wallet, qualityIn, qualityOut);
        const transactionHash = await this.coreXrplClient.signAndSubmitTransaction(trustSetTransaction, wallet);
        return this.coreXrplClient.getFinalTransactionResultAsync(transactionHash, wallet);
    }
    /**
     * Prepares a TrustSet transaction to be sent and executed on the XRPL.
     *
     * @param accountToTrust The account to extend trust to with a trust line.
     * @param currencyName The name of the currency to create a trust line for.
     * @param amount The maximum amount of debt to allow on this trust line.
     * @param wallet A wallet associated with the account extending trust.
     * @param qualityIn (Optional) Value incoming balances on this trust line at the ratio of this number per 1,000,000,000 units.
     *                  A value of 0 is shorthand for treating balances at face value.
     * @param qualityOut (Optional) Value outgoing balances on this trust line at the ratio of this number per 1,000,000,000 units.
     *                  A value of 0 is shorthand for treating balances at face value.
     */
    async prepareTrustSetTransaction(accountToTrust, currencyName, amount, flags, wallet, qualityInAmount, qualityOutAmount) {
        if (!xrp_utils_1.default.isValidXAddress(accountToTrust)) {
            throw shared_1.XrpError.xAddressRequired;
        }
        const classicAddress = xrp_utils_1.default.decodeXAddress(accountToTrust);
        if (!classicAddress) {
            throw shared_1.XrpError.xAddressRequired;
        }
        // TODO (tedkalaw): Use X-Address directly when ripple-binary-codec supports X-Addresses.
        const issuerAccountAddress = new account_pb_1.AccountAddress();
        issuerAccountAddress.setAddress(classicAddress.address);
        if (currencyName === 'XRP') {
            throw new shared_1.XrpError(shared_1.XrpErrorType.InvalidInput, 'prepareTrustSetTransaction: Trust lines can only be created for Issued Currencies');
        }
        const currency = new amount_pb_1.Currency();
        currency.setName(currencyName);
        const issuedCurrencyAmount = new amount_pb_1.IssuedCurrencyAmount();
        issuedCurrencyAmount.setCurrency(currency);
        issuedCurrencyAmount.setIssuer(issuerAccountAddress);
        // TODO (tedkalaw): Support other types of amounts (number, bigInt, etc)
        issuedCurrencyAmount.setValue(amount);
        const currencyAmount = new amount_pb_1.CurrencyAmount();
        currencyAmount.setIssuedCurrencyAmount(issuedCurrencyAmount);
        const limit = new common_pb_1.LimitAmount();
        limit.setValue(currencyAmount);
        const trustSet = new transaction_pb_1.TrustSet();
        trustSet.setLimitAmount(limit);
        if (qualityInAmount) {
            const qualityIn = new common_pb_1.QualityIn();
            qualityIn.setValue(qualityInAmount);
            trustSet.setQualityIn(qualityIn);
        }
        if (qualityOutAmount) {
            const qualityOut = new common_pb_1.QualityOut();
            qualityOut.setValue(qualityOutAmount);
            trustSet.setQualityOut(qualityOut);
        }
        const transaction = await this.coreXrplClient.prepareBaseTransaction(wallet);
        transaction.setTrustSet(trustSet);
        if (flags !== undefined) {
            const transactionFlags = new common_pb_1.Flags();
            transactionFlags.setValue(flags);
            transaction.setFlags(transactionFlags);
        }
        return transaction;
    }
    /**
     * Creates new issued currency on a trustline to the destination account. Note that the destination account must have a trustline
     * extended to the sender of this transaction (the "issuer" of this issued currency) or no issued currency will be created.
     *
     * @param sender The Wallet creating the issued currency, and that will sign the transaction.
     * @param destination The destination address (recipient) of the issued currency, encoded as an X-address (see https://xrpaddress.info/).
     * @param currency The three-letter currency code of the issued currency being created.
     * @param amount The amount of issued currency to create.
     */
    async createIssuedCurrency(sender, destination, currency, amount) {
        const issuer = sender.getAddress();
        const issuedCurrency = {
            currency,
            issuer,
            value: amount,
        };
        return this.issuedCurrencyPayment(sender, destination, issuedCurrency);
    }
    /**
     * Redeems issued currency back to the original issuer.
     * Typically, this should trigger off-ledger action by the issuing institution.
     *
     * @param sender The Wallet redeeming the issued currency, and that will sign the transaction.
     * @param issuer The original issuer of the issued currency, encoded as an X-address (see https://xrpaddress.info/).
     * @param currency The three-letter currency code of the issued currency being redeemed.
     * @param amount The amount of issued currency to redeem.
     */
    async redeemIssuedCurrency(sender, issuedCurrency) {
        // Redemption of issued currency is achieved by sending issued currency directly to the original issuer.
        // However, the issuer field specified in the amount is treated as a special case in this circumstance, and should be
        // set to the address of the account initiating the redemption.
        // See: https://xrpl.org/payment.html#special-issuer-values-for-sendmax-and-amount
        const specialIssuedCurrency = Object.assign(Object.assign({}, issuedCurrency), { issuer: sender.getAddress() });
        return this.issuedCurrencyPayment(sender, issuedCurrency.issuer, specialIssuedCurrency);
    }
    /**
     * Sends issued currency from one (non-issuing) account to another.
     *
     * @param sender The Wallet from which issued currency will be sent, and that will sign the transaction.
     * @param destination The destination address for the payment, encoded as an X-address (see https://xrpaddress.info/).
     * @param issuedCurrency The issued currency being sent.
     * @param transferFee (Optional) The transfer fee associated with the issuing account, expressed as a percentage. (i.e. a value of .5 indicates
     *               a 0.5% transfer fee).  Supply this field for automatic calculation of the sendMax value for this payment.
     *               Either this or sendMaxvalue may be specified, but not both.
     * @param sendMaxValue (Optional) A manual specification of the maximum amount of source currency this payment is allowed to cost,
     *               including transfer fees, exchange rates, and slippage. Does not include the XRP destroyed as a cost for submitting
     *               the transaction. Either this or transferFee may be specified, but not both.
     */
    async sendIssuedCurrencyPayment(sender, destination, issuedCurrency, transferFee, sendMaxValue) {
        if (sender.getAddress() === issuedCurrency.issuer) {
            throw new shared_1.XrpError(shared_1.XrpErrorType.InvalidInput, 'The sending address cannot be the same as the issuing address. To create issued currency, use `createIssuedCurrency`.');
        }
        if (destination === issuedCurrency.issuer) {
            throw new shared_1.XrpError(shared_1.XrpErrorType.InvalidInput, 'The destination address cannot be the same as the issuer. To redeem issued currency, use `redeemIssuedCurrency`.');
        }
        return this.issuedCurrencyPayment(sender, destination, issuedCurrency, transferFee, sendMaxValue);
    }
    /**
     * Send a cross-currency payment. Note that the source and destination currencies cannot both be XRP.
     * The XRPL is queried for viable paths as part of transaction construction.  If no paths are found,
     * an error is thrown and no transaction is submitted.
     *
     * @see https://xrpl.org/cross-currency-payments.html
     *
     * @param sender The wallet from which currency will be sent, and that will sign the transaction.
     * @param destination The address of the payment's recipient, encoded as an X-Address.
     * @param maxSourceAmount Highest amount of source currency this transaction is allowed to cost, including transfer fees,
     *               exchange rates, and slippage. Does not include the XRP destroyed as a cost for submitting the transaction.
     *               For XRP, specify amount as a string of drops.
     *               For issued currencies, specify an IssuedCurrency object with currency, issuer, and value fields.
     * @param deliverAmount The amount of currency to deliver. For XRP, specify amount as a string of drops.  For issued currencies,
     *               specify an IssuedCurrency object with currency, issuer, and value fields.
     */
    async sendCrossCurrencyPayment(sender, destination, maxSourceAmount, deliverAmount) {
        if (!xrp_utils_1.default.isValidXAddress(destination)) {
            throw new shared_1.XrpError(shared_1.XrpErrorType.XAddressRequired, 'Destination address must be in X-address format.  See https://xrpaddress.info/.');
        }
        // Both source amount and deliver amount can't both be XRP:
        if (xrp_utils_1.default.isString(deliverAmount) &&
            xrp_utils_1.default.isString(maxSourceAmount)) {
            throw new shared_1.XrpError(shared_1.XrpErrorType.InvalidInput, 'A cross-currency payment should involve at least one issued currency.');
        }
        if (xrp_utils_1.default.isIssuedCurrency(deliverAmount) &&
            xrp_utils_1.default.isIssuedCurrency(maxSourceAmount) &&
            deliverAmount.currency ===
                maxSourceAmount.currency &&
            deliverAmount.issuer ===
                maxSourceAmount.issuer) {
            throw new shared_1.XrpError(shared_1.XrpErrorType.InvalidInput, 'A Cross Currency payment must specify different currencies for deliverAmount and maxSourceAmount.');
        }
        // Create representation of the currency to SOURCE
        const sourceAmountProto = this.createCurrencyAmount(maxSourceAmount);
        // Create representation of the currency to DELIVER
        const deliverAmountProto = this.createAmount(deliverAmount);
        // Create destination proto
        const destinationAccountAddress = new account_pb_1.AccountAddress();
        destinationAccountAddress.setAddress(destination);
        const destinationProto = new common_pb_1.Destination();
        destinationProto.setValue(destinationAccountAddress);
        // Construct Payment fields
        const payment = new transaction_pb_1.Payment();
        payment.setDestination(destinationProto);
        // Note that the destinationTag doesn't need to be explicitly set here, because the ripple-binary-codec will decode this X-Address and
        // assign the decoded destinationTag before signing.
        payment.setAmount(deliverAmountProto);
        // Assign sourceCurrencyAmount as sendMax for Payment
        const sendMax = new common_pb_2.SendMax();
        sendMax.setValue(sourceAmountProto);
        payment.setSendMax(sendMax);
        // Determine if there is a viable path
        const sourceCurrencyName = xrp_utils_1.default.isString(maxSourceAmount)
            ? 'XRP'
            : maxSourceAmount.currency;
        const sourceCurrency = {
            currency: sourceCurrencyName,
        };
        const sourceCurrencies = [sourceCurrency];
        const sourceClassicAddress = xrp_utils_1.default.decodeXAddress(sender.getAddress());
        if (!sourceClassicAddress) {
            throw shared_1.XrpError.xAddressRequired;
        }
        const destinationClassicAddress = xrp_utils_1.default.decodeXAddress(destination);
        if (!destinationClassicAddress) {
            throw shared_1.XrpError.xAddressRequired;
        }
        let pathFindResponse = await this.webSocketNetworkClient.findRipplePath(sourceClassicAddress.address, destinationClassicAddress.address, deliverAmount, undefined, sourceCurrencies);
        // If failure response from websocket, throw
        if (pathFindResponse.status !== 'success') {
            pathFindResponse = pathFindResponse;
            throw new shared_1.XrpError(shared_1.XrpErrorType.Unknown, pathFindResponse.error_message);
        }
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
        pathFindResponse = pathFindResponse;
        const pathAlternatives = pathFindResponse.result.alternatives;
        // If no viable paths exist, throw
        if (pathAlternatives.length === 0) {
            throw new shared_1.XrpError(shared_1.XrpErrorType.NoViablePaths, 'No paths exist to execute cross-currency payment.');
        }
        // Otherwise, find the cheapest path
        let currentBestPathset = pathAlternatives[0].paths_computed;
        let currentCheapestSourceAmount = new bignumber_js_1.BigNumber(
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
        pathAlternatives[0].source_amount.value);
        pathAlternatives.forEach((possiblePath) => {
            const numericSourceAmount = new bignumber_js_1.BigNumber(possiblePath.source_amount.value);
            if (numericSourceAmount < currentCheapestSourceAmount) {
                currentBestPathset = possiblePath.paths_computed;
                currentCheapestSourceAmount = numericSourceAmount;
            }
        });
        // Assign best pathset to Payment protobuf
        currentBestPathset.forEach((path) => {
            const pathProto = new transaction_pb_1.Payment.Path();
            path.forEach((pathElement) => {
                const pathElementProto = new transaction_pb_1.Payment.PathElement();
                if (pathElement.account) {
                    const accountAddressProto = new account_pb_1.AccountAddress();
                    accountAddressProto.setAddress(pathElement.account);
                    pathElementProto.setAccount(accountAddressProto);
                }
                if (pathElement.currency) {
                    const currencyProto = new amount_pb_1.Currency();
                    currencyProto.setName(pathElement.currency);
                    pathElementProto.setCurrency(currencyProto);
                }
                if (pathElement.issuer) {
                    const issuerAccountAddressProto = new account_pb_1.AccountAddress();
                    issuerAccountAddressProto.setAddress(pathElement.issuer);
                    pathElementProto.setIssuer(issuerAccountAddressProto);
                }
                pathProto.addElements(pathElementProto);
            });
            payment.addPaths(pathProto);
        });
        const transaction = await this.coreXrplClient.prepareBaseTransaction(sender);
        transaction.setPayment(payment);
        const transactionHash = await this.coreXrplClient.signAndSubmitTransaction(transaction, sender);
        return this.coreXrplClient.getFinalTransactionResultAsync(transactionHash, sender);
    }
    // TODO: (acorso) Make this method private and expose more opinionated public APIs.
    // TODO: (acorso) structure this like we have `sendXrp` v.s. `sendXrpWithDetails` to allow for additional optional fields, such as memos.
    //  as well as potentially:
    // TODO: (acorso) learn about partial payments and whether they're essential to offer WRT to issued currencies (https://xrpl.org/payment.html#partial-payments)
    // TODO: (acorso) learn about other payment flags and whether they're essential to offer WRT to issued currencies (https://xrpl.org/payment.html#payment-flags)
    /**
     * Sends issued currency from one account to another.  This method can be used to create issued currency, dispense issued currency from
     * an operational address, send issued currency from one XRPL account to another (as long as the payment only involves a single currency,
     * i.e. is not cross-currency), or to redeem issued currency at the issuing address.
     * The specific case being executed is determined by the relationship among the parameters.
     *
     * @param sender The Wallet from which issued currency will be sent, and that will sign the transaction.
     * @param destination The destination address (recipient) for the payment, encoded as an X-address (see https://xrpaddress.info/).
     * @param issuedCurrency The issued currency being sent.
     * @param transferFee (Optional) The transfer fee associated with the issuing account, expressed as a percentage. (i.e. a value of .5 indicates
     *               a 0.5% transfer fee).  Supply this field for automatic calculation of the sendMax value for this payment.
     *               Either this or sendMaxvalue may be specified, but not both.
     * @param sendMaxValue (Optional) A manual specification of the maximum amount of source currency this payment is allowed to cost,
     *               including transfer fees, exchange rates, and slippage. Does not include the XRP destroyed as a cost for submitting \
     *               the transaction. Either this or transferFee may be specified, but not both.
     */
    async issuedCurrencyPayment(sender, destination, issuedCurrency, transferFee, sendMaxValue) {
        if (transferFee && sendMaxValue) {
            throw new shared_1.XrpError(shared_1.XrpErrorType.InvalidInput, 'Specify the `transferFee` or `sendMaxValue` fields, but not both.');
        }
        if (!xrp_utils_1.default.isValidXAddress(destination)) {
            throw new shared_1.XrpError(shared_1.XrpErrorType.XAddressRequired, 'Destination address must be in X-address format.  See https://xrpaddress.info/.');
        }
        // TODO: (acorso) we don't need to convert back to a classic address once the ripple-binary-codec supports X-addresses for issued currencies.
        const issuerClassicAddress = xrp_utils_1.default.decodeXAddress(issuedCurrency.issuer);
        if (!issuerClassicAddress) {
            throw new shared_1.XrpError(shared_1.XrpErrorType.XAddressRequired, 'Issuer address must be in X-address format.  See https://xrpaddress.info/.');
        }
        if (!issuerClassicAddress.address) {
            throw new shared_1.XrpError(shared_1.XrpErrorType.XAddressRequired, 'Decoded classic address is missing address field.');
        }
        const currencyProto = new amount_pb_1.Currency();
        currencyProto.setName(issuedCurrency.currency);
        const issuerAccountAddress = new account_pb_1.AccountAddress();
        issuerAccountAddress.setAddress(issuerClassicAddress.address);
        const issuedCurrencyAmount = new amount_pb_1.IssuedCurrencyAmount();
        issuedCurrencyAmount.setCurrency(currencyProto);
        issuedCurrencyAmount.setIssuer(issuerAccountAddress);
        issuedCurrencyAmount.setValue(issuedCurrency.value);
        const currencyAmount = new amount_pb_1.CurrencyAmount();
        currencyAmount.setIssuedCurrencyAmount(issuedCurrencyAmount);
        const amountProto = new common_pb_1.Amount();
        amountProto.setValue(currencyAmount);
        const destinationAccountAddress = new account_pb_1.AccountAddress();
        destinationAccountAddress.setAddress(destination);
        const destinationProto = new common_pb_1.Destination();
        destinationProto.setValue(destinationAccountAddress);
        // Construct Payment fields
        const payment = new transaction_pb_1.Payment();
        payment.setDestination(destinationProto);
        // Note that the destinationTag doesn't need to be explicitly set here, because the ripple-binary-codec will decode this X-Address and
        // assign the decoded destinationTag before signing.
        payment.setAmount(amountProto);
        // If transferFee was supplied, calculate the sendMax value, otherwise use the manual override sendMaxValue.
        // Either or both may be undefined.
        const calculatedSendMaxValue = transferFee
            ? this.calculateSendMaxValue(issuedCurrency.value, transferFee)
            : sendMaxValue;
        if (calculatedSendMaxValue) {
            const sendMaxIssuedCurrencyAmount = new amount_pb_1.IssuedCurrencyAmount();
            sendMaxIssuedCurrencyAmount.setCurrency(currencyProto);
            sendMaxIssuedCurrencyAmount.setIssuer(issuerAccountAddress);
            sendMaxIssuedCurrencyAmount.setValue(calculatedSendMaxValue);
            const sendMaxCurrencyAmount = new amount_pb_1.CurrencyAmount();
            sendMaxCurrencyAmount.setIssuedCurrencyAmount(sendMaxIssuedCurrencyAmount);
            const sendMax = new common_pb_2.SendMax();
            sendMax.setValue(sendMaxCurrencyAmount);
            payment.setSendMax(sendMax);
        }
        const transaction = await this.coreXrplClient.prepareBaseTransaction(sender);
        transaction.setPayment(payment);
        const transactionHash = await this.coreXrplClient.signAndSubmitTransaction(transaction, sender);
        return this.coreXrplClient.getFinalTransactionResultAsync(transactionHash, sender);
    }
    /**
     * Calculates the sendMaxValue by applying the transferFee to the amount being sent and ensuring the total amount
     * fits within maximum decimal precision.
     * @see https://xrpl.org/currency-formats.html#issued-currency-precision
     *
     * @param amount The amount of issued currency to pay to the destination.
     * @param transferFee The transfer fee associated with the issuing account, expressed as a percentage.
     *                    (i.e. a value of .5 indicates a 0.5% transfer fee).
     */
    calculateSendMaxValue(amount, transferFee) {
        if (transferFee < 0) {
            throw new shared_1.XrpError(shared_1.XrpErrorType.InvalidInput, 'Transfer Fee must be positive.');
        }
        // maximum allowed decimal precision for issued currency values.
        const maxDecimalPrecision = 15;
        const numericAmount = new bignumber_js_1.BigNumber(amount);
        const transferRate = new bignumber_js_1.BigNumber(1 + transferFee / 100);
        // calculate the total sendMaxValue with any number of decimal places.
        const rawSendMaxValue = numericAmount.multipliedBy(transferRate);
        if (rawSendMaxValue.toFixed().length <= maxDecimalPrecision) {
            return rawSendMaxValue.toFixed();
        }
        // If we have too many digits of precision, express with scientific notation but fit within decimal precision.
        return rawSendMaxValue.toExponential(14, 0).replace(/e\+/, 'e');
    }
    /**
     * Creates an offer on the XRP Ledger.
     * @see https://xrpl.org/offers.html
     * @see https://xrpl.org/offercreate.html#offercreate
     *
     * @param sender The Wallet creating this offer, and that will sign the transaction.
     * @param takerGetsAmount The amount and type of currency being provided by the offer creator.
     *               Use a string to specify XRP, or an IssuedCurrency object to specify an issued currency.
     * @param takerPaysAmount The amount and type of currency being requested by the offer creator.
     *               Use a string to specify XRP, or an IssuedCurrency object to specify an issued currency.
     * @param offerSequence (Optional) An offer to delete first, specified by the sequence number of a previous OfferCreate transaction.
     *               If specified, cancel any offer object in the ledger that was created by that transaction.
     *               It is not considered an error if the offer specified does not exist.
     * @param expiration (Optional) Time after which the offer is no longer active, in seconds since the Ripple Epoch.
     *               (See https://xrpl.org/basic-data-types.html#specifying-time)
     * @param passive (Optional, defaults to false) If enabled, the offer does not consume offers that exactly match it, and instead becomes
     *               an Offer object in the ledger. It still consumes offers that cross it.
     * @param immediateOrCancel (Optional, defaults to false) Treat the offer as an Immediate or Cancel order. If enabled, the offer never becomes
     *               a ledger object: it only tries to match existing offers in the ledger. If the offer cannot match any offers
     *               immediately, it executes "successfully" without trading any currency. In this case, the transaction has the
     *               result code tesSUCCESS, but creates no Offer objects in the ledger.
     *               (see https://en.wikipedia.org/wiki/Immediate_or_cancel)
     * @param fillOrKill (Optional, defaults to false) Treat the offer as a Fill or Kill order. Only try to match existing offers in the ledger,
     *               and only do so if the entire TakerPays quantity can be obtained. If the fix1578 amendment is enabled and
     *               the offer cannot be executed when placed, the transaction has the result code tecKILLED; otherwise, the
     *               transaction uses the result code tesSUCCESS even when it was killed without trading any currency.
     *               (see https://en.wikipedia.org/wiki/Fill_or_kill)
     * @param sell (Optional, defaults to false) Exchange the entire TakerGets amount, even if it means obtaining more than the TakerPays amount in exchange.
     */
    async createOffer(sender, takerGetsAmount, takerPaysAmount, offerSequence, expiration, passive, immediateOrCancel, fillOrKill, sell) {
        const takerGetsCurrencyAmount = this.createCurrencyAmount(takerGetsAmount);
        const takerGets = new common_pb_2.TakerGets();
        takerGets.setValue(takerGetsCurrencyAmount);
        const takerPaysCurrencyAmount = this.createCurrencyAmount(takerPaysAmount);
        const takerPays = new common_pb_1.TakerPays();
        takerPays.setValue(takerPaysCurrencyAmount);
        const offerCreate = new transaction_pb_2.OfferCreate();
        offerCreate.setTakerGets(takerGets);
        offerCreate.setTakerPays(takerPays);
        if (offerSequence) {
            const offerSequenceProto = new common_pb_2.OfferSequence();
            offerSequenceProto.setValue(offerSequence);
            offerCreate.setOfferSequence(offerSequenceProto);
        }
        if (expiration) {
            const expirationProto = new common_pb_2.Expiration();
            expirationProto.setValue(expiration);
            offerCreate.setExpiration(expirationProto);
        }
        let flagsValue = 0;
        if (passive) {
            flagsValue |= offer_create_flag_1.default.TF_PASSIVE;
        }
        if (immediateOrCancel) {
            flagsValue |= offer_create_flag_1.default.TF_IMMEDIATE_OR_CANCEL;
        }
        if (fillOrKill) {
            flagsValue |= offer_create_flag_1.default.TF_FILL_OR_KILL;
        }
        if (sell) {
            flagsValue |= offer_create_flag_1.default.TF_SELL;
        }
        const flags = new common_pb_1.Flags();
        flags.setValue(flagsValue);
        const transaction = await this.coreXrplClient.prepareBaseTransaction(sender);
        transaction.setOfferCreate(offerCreate);
        if (flagsValue != 0) {
            transaction.setFlags(flags);
        }
        const transactionHash = await this.coreXrplClient.signAndSubmitTransaction(transaction, sender);
        return this.coreXrplClient.getFinalTransactionResultAsync(transactionHash, sender);
    }
    /**
     * Cancels an offer on the XRP Ledger.
     * @see https://xrpl.org/offers.html
     * @see https://xrpl.org/offercancel.html#offercancel
     *
     * @param sender The Wallet cancelling this offer, and that will sign the transaction.
     * @param offerSequence The sequence number of a previous OfferCreate transaction.
     *               If specified, cancel any offer object in the ledger that was created by that transaction.
     *               It is not considered an error if the offer specified does not exist.
     */
    async cancelOffer(sender, offerSequence) {
        const offerSequenceProto = new common_pb_2.OfferSequence();
        offerSequenceProto.setValue(offerSequence);
        const offerCancel = new transaction_pb_2.OfferCancel();
        offerCancel.setOfferSequence(offerSequenceProto);
        const transaction = await this.coreXrplClient.prepareBaseTransaction(sender);
        transaction.setOfferCancel(offerCancel);
        const transactionHash = await this.coreXrplClient.signAndSubmitTransaction(transaction, sender);
        return this.coreXrplClient.getFinalTransactionResultAsync(transactionHash, sender);
    }
    /**
     * Constructs and returns a CurrencyAmount protobuf that represents either an XRP drops amount or Issued Currency amount, which can then be
     * assigned to a higher order protobuf that requires a CurrencyAmount.
     *
     * @param amount The string (for XRP amounts) or IssuedCurrency object (for issued currencies) from which to construct a CurrencyAmount protobuf.
     */
    createCurrencyAmount(amount) {
        const currencyAmount = new amount_pb_1.CurrencyAmount();
        if (xrp_utils_1.default.isString(amount)) {
            const xrpDropsAmount = new amount_pb_1.XRPDropsAmount();
            xrpDropsAmount.setDrops(amount);
            currencyAmount.setXrpAmount(xrpDropsAmount);
        }
        else {
            const currency = new amount_pb_1.Currency();
            currency.setName(amount.currency);
            const accountAddress = new account_pb_1.AccountAddress();
            accountAddress.setAddress(amount.issuer);
            const issuedCurrencyAmount = new amount_pb_1.IssuedCurrencyAmount();
            issuedCurrencyAmount.setIssuer(accountAddress);
            issuedCurrencyAmount.setCurrency(currency);
            issuedCurrencyAmount.setValue(amount.value);
            currencyAmount.setIssuedCurrencyAmount(issuedCurrencyAmount);
        }
        return currencyAmount;
    }
    /**
     * Constructs and returns an Amount protocol buffer object with all sub-objects such as an XRPDropsAmount or IssuedCurrencyAmount.
     *
     * @param amount The string (for XRP amounts) or IssuedCurrency object (for issued currencies) from which to construct a Amount protobuf.
     */
    createAmount(amount) {
        const currencyAmount = this.createCurrencyAmount(amount);
        const amountProto = new common_pb_1.Amount();
        amountProto.setValue(currencyAmount);
        return amountProto;
    }
}
exports.default = IssuedCurrencyClient;
//# sourceMappingURL=issued-currency-client.js.map