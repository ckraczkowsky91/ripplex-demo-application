"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const xpring_common_js_1 = require("xpring-common-js");
const xrp_utils_1 = __importDefault(require("./shared/xrp-utils"));
const big_integer_1 = __importDefault(require("big-integer"));
const grpc_web_1 = require("grpc-web");
const amount_pb_1 = require("./Generated/web/org/xrpl/rpc/v1/amount_pb");
const common_pb_1 = require("./Generated/web/org/xrpl/rpc/v1/common_pb");
const transaction_pb_1 = require("./Generated/web/org/xrpl/rpc/v1/transaction_pb");
const account_pb_1 = require("./Generated/web/org/xrpl/rpc/v1/account_pb");
const transaction_status_1 = __importDefault(require("./shared/transaction-status"));
const xrp_transaction_1 = __importDefault(require("./protobuf-wrappers/xrp-transaction"));
const grpc_xrp_network_client_1 = __importDefault(require("./network-clients/grpc-xrp-network-client"));
const grpc_xrp_network_client_web_1 = __importDefault(require("./network-clients/grpc-xrp-network-client.web"));
const utils_1 = __importDefault(require("../Common/utils"));
const xrp_error_1 = __importDefault(require("./shared/xrp-error"));
const ledger_pb_1 = require("./Generated/web/org/xrpl/rpc/v1/ledger_pb");
const account_set_flag_1 = require("./shared/account-set-flag");
const transaction_result_1 = __importDefault(require("./shared/transaction-result"));
const core_xrpl_client_1 = __importDefault(require("./core-xrpl-client"));
/**
 * DefaultXrpClient is a client for handling XRP payments on the XRPL.
 */
class DefaultXrpClient {
    /**
     * Create a new DefaultXrpClient with a custom network client implementation.
     *
     * In general, clients should prefer to call `xrpClientWithEndpoint`. This constructor is provided to improve testability of this class.
     *
     * @param networkClient A network client which will manage remote RPCs to Rippled.
     * @param network The network this XrpClient is connecting to.
     */
    constructor(networkClient, network) {
        this.networkClient = networkClient;
        this.network = network;
        this.coreXrplClient = new core_xrpl_client_1.default(networkClient, network);
    }
    /**
     * Create a new DefaultXrpClient.
     *
     * The DefaultXrpClient will use gRPC to communicate with the given endpoint.
     *
     * @param grpcUrl The URL of the gRPC instance to connect to.
     * @param network The network this XrpClient is connecting to.
     * @param forceWeb If `true`, then we will use the gRPC-Web client even when on Node. Defaults to false. This is mainly for testing and in the future will be removed when we have browser testing.
     */
    static defaultXrpClientWithEndpoint(grpcUrl, network, forceWeb = false) {
        return utils_1.default() && !forceWeb
            ? new DefaultXrpClient(new grpc_xrp_network_client_1.default(grpcUrl), network)
            : new DefaultXrpClient(new grpc_xrp_network_client_web_1.default(grpcUrl), network);
    }
    /**
     * Retrieve the balance for the given address.
     *
     * @param address The X-Address to retrieve a balance for.
     * @returns A `BigInteger` representing the number of drops of XRP in the account.
     */
    async getBalance(address) {
        var _a, _b, _c;
        const classicAddress = xrp_utils_1.default.decodeXAddress(address);
        if (!classicAddress) {
            throw xrp_error_1.default.xAddressRequired;
        }
        const account = this.networkClient.AccountAddress();
        account.setAddress(classicAddress.address);
        const request = this.networkClient.GetAccountInfoRequest();
        request.setAccount(account);
        const ledger = new ledger_pb_1.LedgerSpecifier();
        ledger.setShortcut(ledger_pb_1.LedgerSpecifier.Shortcut.SHORTCUT_VALIDATED);
        request.setLedger(ledger);
        const accountInfo = await this.networkClient.getAccountInfo(request);
        const accountData = accountInfo.getAccountData();
        if (!accountData) {
            throw xrp_error_1.default.malformedResponse;
        }
        const balance = (_c = (_b = (_a = accountData
            .getBalance()) === null || _a === void 0 ? void 0 : _a.getValue()) === null || _b === void 0 ? void 0 : _b.getXrpAmount()) === null || _c === void 0 ? void 0 : _c.getDrops();
        if (!balance) {
            throw xrp_error_1.default.malformedResponse;
        }
        return big_integer_1.default(balance);
    }
    /**
     * Retrieve the transaction status for a Payment given transaction hash.
     *
     * Note: This method will only work for Payment type transactions which do not have the tf_partial_payment attribute set.
     * @see https://xrpl.org/payment.html#payment-flags
     *
     * @param transactionHash The hash of the transaction.
     * @returns The status of the given transaction.
     */
    async getPaymentStatus(transactionHash) {
        return await this.coreXrplClient.getTransactionStatus(transactionHash);
    }
    /**
     * Send the given amount of XRP from the source wallet to the destination address.
     *
     * @param amount A `BigInteger`, number or numeric string representing the number of drops of XRP to send.
     * @param destinationAddress A destination address to send the drops to.
     * @param sender The wallet that XRP will be sent from and which will sign the request.
     * @returns A promise which resolves to a TransactionResult representing the pending outcome of the submitted transaction.
     */
    async sendXrp(amount, destinationAddress, sender) {
        return await this.sendXrpWithDetails({
            amount,
            destination: destinationAddress,
            sender,
        });
    }
    /**
     * Send the given amount of XRP from the source wallet to the destination address, allowing
     * for additional details to be specified for use with supplementary features of the XRP ledger.
     *
     * @param sendXrpDetails - a wrapper object containing details for constructing a transaction.
     * @returns A promise which resolves to a TransactionResult representing the pending outcome of the submitted transaction.
     */
    async sendXrpWithDetails(sendXrpDetails) {
        const { amount: drops, sender, destination: destinationAddress, memoList, } = sendXrpDetails;
        if (!xrp_utils_1.default.isValidXAddress(destinationAddress)) {
            throw xrp_error_1.default.xAddressRequired;
        }
        const normalizedDrops = drops.toString();
        const xrpDropsAmount = new amount_pb_1.XRPDropsAmount();
        xrpDropsAmount.setDrops(normalizedDrops);
        const currencyAmount = new amount_pb_1.CurrencyAmount();
        currencyAmount.setXrpAmount(xrpDropsAmount);
        const amount = new common_pb_1.Amount();
        amount.setValue(currencyAmount);
        const destinationAccountAddress = new account_pb_1.AccountAddress();
        destinationAccountAddress.setAddress(destinationAddress);
        const destination = new common_pb_1.Destination();
        destination.setValue(destinationAccountAddress);
        const payment = new transaction_pb_1.Payment();
        payment.setDestination(destination);
        // Note that the destinationTag doesn't need to be explicitly set here, because the ripple-binary-codec will decode this X-Address and
        // assign the decoded destinationTag before signing.
        payment.setAmount(amount);
        const transaction = await this.coreXrplClient.prepareBaseTransaction(sender);
        transaction.setPayment(payment);
        if (memoList && memoList.length) {
            memoList
                .map((memo) => {
                const xrpMemo = new transaction_pb_1.Memo();
                if (memo.data) {
                    const memoData = new common_pb_1.MemoData();
                    memoData.setValue(memo.data);
                    xrpMemo.setMemoData(memoData);
                }
                if (memo.format) {
                    const memoFormat = new common_pb_1.MemoFormat();
                    memoFormat.setValue(memo.format);
                    xrpMemo.setMemoFormat(memoFormat);
                }
                if (memo.type) {
                    const memoType = new common_pb_1.MemoType();
                    memoType.setValue(memo.type);
                    xrpMemo.setMemoType(memoType);
                }
                return xrpMemo;
            })
                .forEach((memo) => transaction.addMemos(memo));
        }
        const transactionHash = await this.coreXrplClient.signAndSubmitTransaction(transaction, sender);
        return transaction_result_1.default.createPendingTransactionResult(transactionHash, transaction_status_1.default.Pending, false);
    }
    /**
     * Check if an address exists on the XRP Ledger.
     *
     * @param address The address to check the existence of.
     * @returns A boolean if the account is on the ledger.
     */
    async accountExists(address) {
        const classicAddress = xrp_utils_1.default.decodeXAddress(address);
        if (!classicAddress) {
            throw xrp_error_1.default.xAddressRequired;
        }
        try {
            await this.getBalance(address);
            return true;
        }
        catch (error) {
            if ((error === null || error === void 0 ? void 0 : error.code) === grpc_web_1.StatusCode.NOT_FOUND) {
                return false;
            }
            throw error; // error code other than NOT_FOUND should re-throw error
        }
    }
    /**
     * Return the history of payments for the given account.
     *
     * Note: This method only works for payment type transactions, see: https://xrpl.org/payment.html
     * Note: This method only returns the history that is contained on the remote node, which may not contain a full history of the network.
     *
     * @param address: The address (account) for which to retrieve payment history.
     * @throws: An error if there was a problem communicating with the XRP Ledger.
     * @return: An array of transactions associated with the account.
     */
    async paymentHistory(address) {
        const classicAddress = xrp_utils_1.default.decodeXAddress(address);
        if (!classicAddress) {
            throw xrp_error_1.default.xAddressRequired;
        }
        const account = this.networkClient.AccountAddress();
        account.setAddress(classicAddress.address);
        const request = this.networkClient.GetAccountTransactionHistoryRequest();
        request.setAccount(account);
        const transactionHistory = await this.networkClient.getTransactionHistory(request);
        const getTransactionResponses = transactionHistory.getTransactionsList();
        // Filter transactions to payments only and convert them to XrpTransactions.
        // If a payment transaction fails conversion, throw an error.
        const payments = [];
        // eslint-disable-next-line no-restricted-syntax
        for (const getTransactionResponse of getTransactionResponses) {
            const transaction = getTransactionResponse.getTransaction();
            switch (transaction === null || transaction === void 0 ? void 0 : transaction.getTransactionDataCase()) {
                case transaction_pb_1.Transaction.TransactionDataCase.PAYMENT: {
                    const xrpTransaction = xrp_transaction_1.default.from(getTransactionResponse, this.network);
                    payments.push(xrpTransaction);
                    break;
                }
                default:
                // Intentionally do nothing, non-payment type transactions are ignored.
            }
        } // end for
        return payments;
    }
    /**
     * Retrieve the payment transaction corresponding to the given transaction hash.
     *
     * Note: This method can return transactions that are not included in a fully validated ledger.
     *       See the `validated` field to make this distinction.
     *
     * @param transactionHash The hash of the transaction to retrieve.
     * @throws An error if the transaction hash was invalid.
     * @returns An {@link XrpTransaction} object representing an XRP Ledger transaction.
     */
    async getPayment(transactionHash) {
        const getTransactionRequest = this.networkClient.GetTransactionRequest();
        getTransactionRequest.setHash(xpring_common_js_1.Utils.toBytes(transactionHash));
        const getTransactionResponse = await this.networkClient.getTransaction(getTransactionRequest);
        return xrp_transaction_1.default.from(getTransactionResponse, this.network);
    }
    /**
     * Enable Deposit Authorization for this XRPL account.
     *
     * @see https://xrpl.org/depositauth.html
     *
     * @param wallet The wallet associated with the XRPL account enabling Deposit Authorization and that will sign the request.
     * @returns A promise which resolves to a TransactionResult object that represents the result of this transaction.
     */
    async enableDepositAuth(wallet) {
        return this.coreXrplClient.changeFlag(account_set_flag_1.AccountSetFlag.asfDepositAuth, true, wallet);
    }
    /**
     * Enables DepositPreauth and authorizes an XRPL account to send to this XRPL account.
     *
     * @see https://xrpl.org/depositpreauth.html
     *
     * @param xAddressToAuthorize The X-Address of the sender to enable DepositPreauth for.
     * @param wallet The wallet associated with the XRPL account enabling a deposit preauthorization and that will sign the request.
     */
    async authorizeSendingAccount(xAddressToAuthorize, wallet) {
        const classicAddress = xrp_utils_1.default.decodeXAddress(xAddressToAuthorize);
        if (!classicAddress) {
            throw xrp_error_1.default.xAddressRequired;
        }
        const accountAddressToAuthorize = new account_pb_1.AccountAddress();
        accountAddressToAuthorize.setAddress(xAddressToAuthorize);
        const authorize = new common_pb_1.Authorize();
        authorize.setValue(accountAddressToAuthorize);
        const depositPreauth = new transaction_pb_1.DepositPreauth();
        depositPreauth.setAuthorize(authorize);
        const transaction = await this.coreXrplClient.prepareBaseTransaction(wallet);
        transaction.setDepositPreauth(depositPreauth);
        const transactionHash = await this.coreXrplClient.signAndSubmitTransaction(transaction, wallet);
        return await this.coreXrplClient.getTransactionResult(transactionHash);
    }
    /**
     * Disables DepositPreauth and unauthorizes an XRPL account to send to this XRPL account.
     *
     * @see https://xrpl.org/depositpreauth.html
     *
     * @param xAddressToUnauthorize The X-Address of the sender to unauthorize.
     * @param wallet The wallet associated with the XRPL account revoking a deposit preauthorization, and that will sign the request.
     */
    async unauthorizeSendingAccount(xAddressToUnauthorize, wallet) {
        const classicAddress = xrp_utils_1.default.decodeXAddress(xAddressToUnauthorize);
        if (!classicAddress) {
            throw xrp_error_1.default.xAddressRequired;
        }
        const accountAddressToUnauthorize = new account_pb_1.AccountAddress();
        accountAddressToUnauthorize.setAddress(xAddressToUnauthorize);
        const unauthorize = new common_pb_1.Unauthorize();
        unauthorize.setValue(accountAddressToUnauthorize);
        const depositPreauth = new transaction_pb_1.DepositPreauth();
        depositPreauth.setUnauthorize(unauthorize);
        const transaction = await this.coreXrplClient.prepareBaseTransaction(wallet);
        transaction.setDepositPreauth(depositPreauth);
        const transactionHash = await this.coreXrplClient.signAndSubmitTransaction(transaction, wallet);
        return await this.coreXrplClient.getTransactionResult(transactionHash);
    }
}
exports.default = DefaultXrpClient;
//# sourceMappingURL=default-xrp-client.js.map