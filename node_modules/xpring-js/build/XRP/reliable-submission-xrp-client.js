"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_xrpl_client_1 = __importDefault(require("./core-xrpl-client"));
const default_xrp_client_1 = __importDefault(require("./default-xrp-client"));
/**
 * An XrpClient which blocks on `send` calls until the transaction has reached a deterministic state.
 */
class ReliableSubmissionXrpClient {
    /**
     * A constructor for direct client injection, primarily for testing.
     *
     * @param decoratedClient The XrpClient being decorated by this ReliableSubmissionClient.
     * @param coreXrplClient The instance of CoreXrplClient available to this ReliableSubmissionClient.
     * @param network The network this XrpClient is connecting to.
     */
    constructor(decoratedClient, coreXrplClient, network) {
        this.decoratedClient = decoratedClient;
        this.coreXrplClient = coreXrplClient;
        this.network = network;
    }
    /**
     * Create a new ReliableSubmissionXrpClient.
     *
     * The ReliableSubmissionXrpClient will use gRPC to communicate with the given endpoint.
     *
     * @param grpcUrl The URL of the gRPC instance to connect to.
     * @param network The network this XrpClient is connecting to.
     * @param forceWeb If `true`, then we will use the gRPC-Web client even when on Node. Defaults to false. This is mainly for testing and in the future will be removed when we have browser testing.
     */
    static reliableSubmissionXrpClientWithEndpoint(grpcUrl, network, forceWeb = false) {
        const decoratedClient = default_xrp_client_1.default.defaultXrpClientWithEndpoint(grpcUrl, network, forceWeb);
        const coreXrplClient = core_xrpl_client_1.default.coreXrplClientWithEndpoint(grpcUrl, network, forceWeb);
        return new ReliableSubmissionXrpClient(decoratedClient, coreXrplClient, network);
    }
    async getBalance(address) {
        return this.decoratedClient.getBalance(address);
    }
    async getPaymentStatus(transactionHash) {
        return this.decoratedClient.getPaymentStatus(transactionHash);
    }
    async sendXrp(amount, destination, sender) {
        return this.sendXrpWithDetails({
            amount,
            destination,
            sender,
        });
    }
    async sendXrpWithDetails(sendXrpDetails) {
        const { sender } = sendXrpDetails;
        const pendingTransactionResult = await this.decoratedClient.sendXrpWithDetails(sendXrpDetails);
        const finalTransactionResult = await this.coreXrplClient.getFinalTransactionResultAsync(pendingTransactionResult.hash, sender);
        return finalTransactionResult;
    }
    async accountExists(address) {
        return this.decoratedClient.accountExists(address);
    }
    async paymentHistory(address) {
        return this.decoratedClient.paymentHistory(address);
    }
    async getPayment(transactionHash) {
        return this.decoratedClient.getPayment(transactionHash);
    }
    async enableDepositAuth(wallet) {
        const result = await this.decoratedClient.enableDepositAuth(wallet);
        return await this.coreXrplClient.getFinalTransactionResultAsync(result.hash, wallet);
    }
    async authorizeSendingAccount(xAddressToAuthorize, wallet) {
        const result = await this.decoratedClient.authorizeSendingAccount(xAddressToAuthorize, wallet);
        return await this.coreXrplClient.getFinalTransactionResultAsync(result.hash, wallet);
    }
    async unauthorizeSendingAccount(xAddressToUnauthorize, wallet) {
        const result = await this.decoratedClient.unauthorizeSendingAccount(xAddressToUnauthorize, wallet);
        return await this.coreXrplClient.getFinalTransactionResultAsync(result.hash, wallet);
    }
}
exports.default = ReliableSubmissionXrpClient;
//# sourceMappingURL=reliable-submission-xrp-client.js.map