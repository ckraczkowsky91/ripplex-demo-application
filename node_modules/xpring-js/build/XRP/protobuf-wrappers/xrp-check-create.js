"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const xpring_common_js_1 = require("xpring-common-js");
const xrp_utils_1 = __importDefault(require("../shared/xrp-utils"));
const xrp_currency_amount_1 = __importDefault(require("./xrp-currency-amount"));
/*
 * Represents a CheckCreate transaction on the XRP Ledger.
 *
 * A CheckCreate transaction creates a Check object in the ledger, which is a deferred payment that can be cashed
 * by its intended destination.  The sender of this transaction is the sender of the Check.
 *
 * @see: https://xrpl.org/checkcreate.html
 */
class XrpCheckCreate {
    /**
     * @param destinationXAddress The unique address and (optional) destination tag of the account that can cash the Check,
     *                            encoded as an X-address (see https://xrpaddress.info/).
     * @param sendMax Maximum amount of source currency the Check is allowed to debit the sender, including transfer fees on non-XRP currencies.
     *                The Check can only credit the destination with the same currency (from the same issuer, for non-XRP currencies).
     *                For non-XRP amounts, the nested field names MUST be lower-case.
     * @param expiration (Optional) Time after which the Check is no longer valid, in seconds since the Ripple Epoch.
     * @param invoiceId (Optional) Arbitrary 256-bit hash representing a specific reason or identifier for this Check.
     */
    constructor(destinationXAddress, sendMax, expiration, invoiceId) {
        this.destinationXAddress = destinationXAddress;
        this.sendMax = sendMax;
        this.expiration = expiration;
        this.invoiceId = invoiceId;
    }
    /**
     * Constructs an XrpCheckCreate from a CheckCreate protocol buffer.
     *
     * @param checkCreate a CheckCreate (protobuf object) whose field values will be used to construct an XrpCheckCreate
     * @return an XrpCheckCreate with its fields set via the analogous protobuf fields.
     * @see https://github.com/ripple/rippled/blob/3d86b49dae8173344b39deb75e53170a9b6c5284/src/ripple/proto/org/xrpl/rpc/v1/transaction.proto#L145
     */
    static from(checkCreate, xrplNetwork) {
        var _a, _b, _c, _d, _e, _f;
        const destination = (_b = (_a = checkCreate.getDestination()) === null || _a === void 0 ? void 0 : _a.getValue()) === null || _b === void 0 ? void 0 : _b.getAddress();
        if (!destination) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'CheckCreate protobuf is missing `destination` field.');
        }
        const destinationTag = (_c = checkCreate.getDestinationTag()) === null || _c === void 0 ? void 0 : _c.getValue();
        const destinationXAddress = xrp_utils_1.default.encodeXAddress(destination, destinationTag, xrplNetwork == xpring_common_js_1.XrplNetwork.Test || xrplNetwork == xpring_common_js_1.XrplNetwork.Dev);
        if (!destinationXAddress) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Cannot construct XAddress from CheckCreate protobuf `destination` and `destinationTag` fields.');
        }
        const sendMaxCurrencyAmount = (_d = checkCreate.getSendMax()) === null || _d === void 0 ? void 0 : _d.getValue();
        if (sendMaxCurrencyAmount == undefined) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'CheckCreate protobuf is missing `SendMax` field.');
        }
        const sendMax = xrp_currency_amount_1.default.from(sendMaxCurrencyAmount);
        const expiration = (_e = checkCreate.getExpiration()) === null || _e === void 0 ? void 0 : _e.getValue();
        const invoiceId = (_f = checkCreate.getInvoiceId()) === null || _f === void 0 ? void 0 : _f.getValue_asB64();
        return new XrpCheckCreate(destinationXAddress, sendMax, expiration, invoiceId);
    }
}
exports.default = XrpCheckCreate;
//# sourceMappingURL=xrp-check-create.js.map