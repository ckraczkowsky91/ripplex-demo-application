"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const xpring_common_js_1 = require("xpring-common-js");
const xrp_utils_1 = __importDefault(require("../shared/xrp-utils"));
const transaction_pb_1 = require("../Generated/web/org/xrpl/rpc/v1/transaction_pb");
const xrp_signer_1 = __importDefault(require("./xrp-signer"));
const xrp_transaction_type_1 = __importDefault(require("../shared/xrp-transaction-type"));
const xrp_payment_1 = __importDefault(require("./xrp-payment"));
const xrp_memo_1 = __importDefault(require("./xrp-memo"));
/**
 * A transaction on the XRP Ledger.
 *
 * @see: https://xrpl.org/transaction-formats.html
 */
class XrpTransaction {
    /**
     * @param hash The identifying hash of the transaction.
     * @param accountTransactionID (Optional) Hash value identifying another transaction.
     *                              If provided, this transaction is only valid if the sending account's
     *                              previously-sent transaction matches the provided hash.
     * @param fee Integer amount of XRP, in drops, to be destroyed as a cost for distributing this transaction to the network.
     * @param flags (Optional) Set of bit-flags for this transaction.
     * @param lastLedgerSequence (Optional; strongly recommended) Highest ledger index this transaction can appear in.
     *                            Specifying this field places a strict upper limit on how long the transaction can wait to be
     *                            validated or rejected.
     * @param memos (Optional) Additional arbitrary information used to identify this transaction.
     * @param sequence The sequence number of the account sending the transaction. A transaction is only valid if the Sequence
     *                  number is exactly 1 greater than the previous transaction from the same account.
     * @param signers (Optional) Array of objects that represent a multi-signature which authorizes this transaction.
     * @param signingPublicKey Hex representation of the public key that corresponds to the private key used to sign this transaction.
     *                         If an empty string, indicates a multi-signature is present in the Signers field instead.
     * @param sourceXAddress: The unique address and source tag of the sender that initiated the transaction, encoded as an X-address.
     *                        See "https://xrpaddress.info"
     * @param transactionSignature The signature that verifies this transaction as originating from the account it says it is from.
     * @param type The type of transaction.
     * @param paymentFields An XrpPayment object representing the additional fields present in a PAYMENT transaction.
     *                      See "https://xrpl.org/payment.html#payment-fields"
     * @param deliveredAmount The actual amount delivered by this transaction, in the case of a partial payment.
     *                        See "https://xrpl.org/partial-payments.html#the-delivered_amount-field"
     * @param timestamp The transaction's timestamp, converted to a unix timestamp.
     * @param validated A boolean indicating whether or not this transaction was found on a validated ledger, and not an open or closed ledger.
     *                  See "https://xrpl.org/ledgers.html#open-closed-and-validated-ledgers"
     * @param ledgerIndex The index of the ledger on which this transaction was found.
     */
    constructor(hash, sourceXAddress, type, fee, sequence, signingPublicKey, transactionSignature, validated, ledgerIndex, accountTransactionID, flags, lastLedgerSequence, memos, signers, paymentFields, timestamp, deliveredAmount) {
        this.hash = hash;
        this.sourceXAddress = sourceXAddress;
        this.type = type;
        this.fee = fee;
        this.sequence = sequence;
        this.signingPublicKey = signingPublicKey;
        this.transactionSignature = transactionSignature;
        this.validated = validated;
        this.ledgerIndex = ledgerIndex;
        this.accountTransactionID = accountTransactionID;
        this.flags = flags;
        this.lastLedgerSequence = lastLedgerSequence;
        this.memos = memos;
        this.signers = signers;
        this.paymentFields = paymentFields;
        this.timestamp = timestamp;
        this.deliveredAmount = deliveredAmount;
    }
    /**
     * Constructs an XrpTransaction from a Transaction.
     *
     * @param transaction a Transaction (protobuf object) whose field values will be used
     *                    to construct an XrpTransaction
     * @param xrplNetwork The XRP Ledger network from which this object was retrieved.
     * @returns an XrpTransaction with its fields set via the analogous protobuf fields.
     * @see https://github.com/ripple/rippled/blob/develop/src/ripple/proto/org/xrpl/rpc/v1/transaction.proto#L13
     */
    static from(getTransactionResponse, xrplNetwork) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        const transaction = getTransactionResponse.getTransaction();
        if (!transaction) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Transaction protobuf is missing valid `transaction` field.');
        }
        const account = (_b = (_a = transaction.getAccount()) === null || _a === void 0 ? void 0 : _a.getValue()) === null || _b === void 0 ? void 0 : _b.getAddress();
        if (!account) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Transaction protobuf is missing valid `account` field.');
        }
        const sourceTag = (_c = transaction.getSourceTag()) === null || _c === void 0 ? void 0 : _c.getValue();
        const sourceXAddress = xrp_utils_1.default.encodeXAddress(account, sourceTag, xrplNetwork === xpring_common_js_1.XrplNetwork.Test || xrplNetwork === xpring_common_js_1.XrplNetwork.Dev);
        if (!sourceXAddress) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Cannot construct XAddress from Transaction protobuf `account` and `sourceTag` fields.');
        }
        const fee = (_d = transaction.getFee()) === null || _d === void 0 ? void 0 : _d.getDrops();
        if (!fee) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Transaction protobuf is missing valid `fee` field.');
        }
        const intFee = Number(fee);
        if (isNaN(intFee)) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Transaction protobuf `fee` field is not a valid integer number of XRP drops.');
        }
        const sequence = (_e = transaction.getSequence()) === null || _e === void 0 ? void 0 : _e.getValue();
        if (!sequence) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Transaction protobuf is missing valid `sequence` field.');
        }
        const accountTransactionID = (_f = transaction
            .getAccountTransactionId()) === null || _f === void 0 ? void 0 : _f.getValue_asU8();
        const flags = (_g = transaction.getFlags()) === null || _g === void 0 ? void 0 : _g.getValue();
        const lastLedgerSequence = (_h = transaction.getLastLedgerSequence()) === null || _h === void 0 ? void 0 : _h.getValue();
        let memos;
        if (transaction.getMemosList().length > 0) {
            memos = transaction.getMemosList().map((memo) => xrp_memo_1.default.from(memo));
        }
        let signers;
        if (transaction.getSignersList().length > 0) {
            signers = transaction
                .getSignersList()
                .map((signer) => xrp_signer_1.default.from(signer, xrplNetwork));
        }
        const signingPublicKey = (_j = transaction.getSigningPublicKey()) === null || _j === void 0 ? void 0 : _j.getValue_asB64();
        if (signingPublicKey === undefined) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Transaction protobuf is missing valid `signingPublicKey` field.');
        }
        if (!signers && signingPublicKey === '') {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Transaction protobuf does not have a `signingPublicKey` field or a `signers` field.');
        }
        const transactionSignature = (_k = transaction
            .getTransactionSignature()) === null || _k === void 0 ? void 0 : _k.getValue_asU8();
        if (!transactionSignature) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Transaction protobuf is missing valid `transactionSignature` field.');
        }
        let paymentFields;
        let type;
        switch (transaction.getTransactionDataCase()) {
            case transaction_pb_1.Transaction.TransactionDataCase.PAYMENT: {
                const payment = transaction.getPayment();
                if (!payment) {
                    throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Transaction protobuf is type Payment but is missing `payment` field.');
                }
                paymentFields = xrp_payment_1.default.from(payment, xrplNetwork);
                type = xrp_transaction_type_1.default.Payment;
                break;
            }
            case transaction_pb_1.Transaction.TransactionDataCase.TRANSACTION_DATA_NOT_SET: {
                throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Transaction protobuf is missing transaction data case.');
            }
            default:
                throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Transaction protobuf is of a transaction type unsupported by xpring-js.');
        }
        const transactionHashBytes = getTransactionResponse.getHash_asU8();
        const transactionHash = xpring_common_js_1.Utils.toHex(transactionHashBytes);
        if (!transactionHash) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Transaction protobuf is missing valid `hash` field.');
        }
        // Transactions report their timestamps since the Ripple Epoch, which is 946,684,800 seconds after
        // the unix epoch. Convert transaction's timestamp to a unix timestamp.
        // See: https://xrpl.org/basic-data-types.html#specifying-time
        const rippleTransactionDate = (_l = getTransactionResponse.getDate()) === null || _l === void 0 ? void 0 : _l.getValue();
        const timestamp = rippleTransactionDate !== undefined
            ? rippleTransactionDate + 946684800
            : undefined;
        const deliveredAmountProto = (_m = getTransactionResponse
            .getMeta()) === null || _m === void 0 ? void 0 : _m.getDeliveredAmount();
        const deliveredAmountXrp = (_p = (_o = deliveredAmountProto === null || deliveredAmountProto === void 0 ? void 0 : deliveredAmountProto.getValue()) === null || _o === void 0 ? void 0 : _o.getXrpAmount()) === null || _p === void 0 ? void 0 : _p.getDrops();
        const deliveredAmountIssuedCurrency = (_r = (_q = deliveredAmountProto === null || deliveredAmountProto === void 0 ? void 0 : deliveredAmountProto.getValue()) === null || _q === void 0 ? void 0 : _q.getIssuedCurrencyAmount()) === null || _r === void 0 ? void 0 : _r.getValue();
        const deliveredAmount = deliveredAmountXrp !== null && deliveredAmountXrp !== void 0 ? deliveredAmountXrp : deliveredAmountIssuedCurrency;
        const validated = getTransactionResponse.getValidated();
        const ledgerIndex = getTransactionResponse.getLedgerIndex();
        return new XrpTransaction(transactionHash, sourceXAddress, type, fee, sequence, signingPublicKey, transactionSignature, validated, ledgerIndex, accountTransactionID, flags, lastLedgerSequence, memos, signers, paymentFields, timestamp, deliveredAmount);
    }
}
exports.default = XrpTransaction;
//# sourceMappingURL=xrp-transaction.js.map