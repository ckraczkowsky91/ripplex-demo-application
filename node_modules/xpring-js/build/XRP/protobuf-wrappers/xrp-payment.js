"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const xpring_common_js_1 = require("xpring-common-js");
const xrp_utils_1 = __importDefault(require("../shared/xrp-utils"));
const xrp_currency_amount_1 = __importDefault(require("./xrp-currency-amount"));
const xrp_path_1 = __importDefault(require("./xrp-path"));
/**
 * Represents a payment on the XRP Ledger.
 * @see: https://xrpl.org/payment.html
 */
class XrpPayment {
    /**
     * @param amount The amount of currency to deliver.
     * @param destinationXAddress The address and (optional) destination tag of the account receiving the payment, encoded in X-address format.
     *                            See https://xrpaddress.info/.
     * @param deliverMin (Optional) Minimum amount of destination currency this transaction should deliver.
     * @param invoiceID (Optional) Arbitrary 256-bit hash representing a specific reason or identifier for this payment.
     * @param paths Array of payment paths to be used for this transaction.  Must be omitted for XRP-to-XRP transactions.
     * @param sendMax (Optional) Highest amount of source currency this transaction is allowed to cost.
     */
    constructor(amount, destinationXAddress, deliverMin, invoiceID, paths, sendMax) {
        this.amount = amount;
        this.destinationXAddress = destinationXAddress;
        this.deliverMin = deliverMin;
        this.invoiceID = invoiceID;
        this.paths = paths;
        this.sendMax = sendMax;
    }
    /**
     * Constructs an XrpPayment from a Payment.
     *
     * @param payment a Payment (protobuf object) whose field values will be used
     *                to construct an XrpPayment
     * @param xrplNetwork The Xrpl network from which this object was retrieved.
     * @return an XrpPayment with its fields set via the analogous protobuf fields.
     * @see https://github.com/ripple/rippled/blob/develop/src/ripple/proto/org/xrpl/rpc/v1/transaction.proto#L224
     */
    static from(payment, xrplNetwork) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const paymentAmountValue = (_a = payment.getAmount()) === null || _a === void 0 ? void 0 : _a.getValue();
        if (paymentAmountValue === undefined) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Payment protobuf is missing required `amount` field.');
        }
        const amount = xrp_currency_amount_1.default.from(paymentAmountValue);
        // For non-XRP amounts, the nested field names in `amount` are lower-case.
        const destination = (_c = (_b = payment.getDestination()) === null || _b === void 0 ? void 0 : _b.getValue()) === null || _c === void 0 ? void 0 : _c.getAddress();
        if (destination === undefined) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Payment protobuf is missing required `destination` field.');
        }
        const destinationTag = (_d = payment.getDestinationTag()) === null || _d === void 0 ? void 0 : _d.getValue();
        const destinationXAddress = xrp_utils_1.default.encodeXAddress(destination, destinationTag, xrplNetwork === xpring_common_js_1.XrplNetwork.Test);
        if (!destinationXAddress) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Payment protobuf destination cannot be encoded into an X-address.');
        }
        const invoiceID = (_e = payment.getInvoiceId()) === null || _e === void 0 ? void 0 : _e.getValue_asU8();
        const paths = ((_f = payment.getPathsList()) === null || _f === void 0 ? void 0 : _f.length) > 0
            ? payment.getPathsList().map((path) => xrp_path_1.default.from(path))
            : undefined;
        if (paths !== undefined && amount.drops !== undefined) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Payment protobuf `paths` field should be omitted for XRP-to-XRP interactions.');
        }
        const paymentSendMaxValue = (_g = payment.getSendMax()) === null || _g === void 0 ? void 0 : _g.getValue();
        const sendMax = paymentSendMaxValue && xrp_currency_amount_1.default.from(paymentSendMaxValue);
        if (sendMax !== undefined && amount.drops !== undefined) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Payment protobuf `sendMax` field should be omitted for XRP-to-XRP interactions.');
        }
        const paymentDeliverMinValue = (_h = payment.getDeliverMin()) === null || _h === void 0 ? void 0 : _h.getValue();
        const deliverMin = paymentDeliverMinValue && xrp_currency_amount_1.default.from(paymentDeliverMinValue);
        // For non-XRP amounts, the nested field names in `deliverMin` are lower-case.
        return new XrpPayment(amount, destinationXAddress, deliverMin, invoiceID, paths, sendMax);
    }
}
exports.default = XrpPayment;
//# sourceMappingURL=xrp-payment.js.map