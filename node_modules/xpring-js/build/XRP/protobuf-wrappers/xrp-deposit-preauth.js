"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const xpring_common_js_1 = require("xpring-common-js");
const xrp_utils_1 = __importDefault(require("../shared/xrp-utils"));
/*
 * Represents a DepositPreauth transaction on the XRP Ledger.
 *
 * A DepositPreauth transaction gives another account pre-approval to deliver payments to the sender of this transaction.
 * This is only useful if the sender of this transaction is using (or plans to use) Deposit Authorization.
 *
 * @see: https://xrpl.org/depositpreauth.html
 */
class XrpDepositPreauth {
    /**
     * Note: authorize and unauthorize are mutually exclusive fields: one but not both should be set.
     *       Addresses are encoded as X-addresses.  See https://xrpaddress.info/.
     * @param authorizeXAddress (Optional) The XRP Ledger address of the sender to preauthorize, encoded as an X-address.
     * @param unauthorizeXAddress (Optional) The XRP Ledger address of a sender whose preauthorization should be revoked,
     *                            encoded as an X-address.
     */
    constructor(authorizeXAddress, unauthorizeXAddress) {
        this.authorizeXAddress = authorizeXAddress;
        this.unauthorizeXAddress = unauthorizeXAddress;
    }
    /**
     * Constructs an XrpDepositPreauth from a DepositPreauth protocol buffer.
     *
     * @param depositPreauth a DepositPreauth (protobuf object) whose field values will be used to construct an XrpDepositPreauth
     * @return an XrpDepositPreauth with its fields set via the analogous protobuf fields.
     * @see https://github.com/ripple/rippled/blob/3d86b49dae8173344b39deb75e53170a9b6c5284/src/ripple/proto/org/xrpl/rpc/v1/transaction.proto#L159
     */
    static from(depositPreauth, xrplNetwork) {
        var _a, _b, _c, _d;
        const authorize = (_b = (_a = depositPreauth.getAuthorize()) === null || _a === void 0 ? void 0 : _a.getValue()) === null || _b === void 0 ? void 0 : _b.getAddress();
        const unauthorize = (_d = (_c = depositPreauth
            .getUnauthorize()) === null || _c === void 0 ? void 0 : _c.getValue()) === null || _d === void 0 ? void 0 : _d.getAddress();
        if (authorize) {
            const authorizeXAddress = xrp_utils_1.default.encodeXAddress(authorize, undefined, xrplNetwork == xpring_common_js_1.XrplNetwork.Test || xrplNetwork == xpring_common_js_1.XrplNetwork.Dev);
            if (!authorizeXAddress) {
                throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Cannot construct XAddress from DepositPreauth protobuf `authorize` field.');
            }
            return new XrpDepositPreauth(authorizeXAddress, undefined);
        }
        if (unauthorize) {
            const unauthorizeXAddress = xrp_utils_1.default.encodeXAddress(unauthorize, undefined, xrplNetwork == xpring_common_js_1.XrplNetwork.Test || xrplNetwork == xpring_common_js_1.XrplNetwork.Dev);
            if (!unauthorizeXAddress) {
                throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Cannot construct XAddress from DepositPreauth protobuf `unauthorize` field.');
            }
            return new XrpDepositPreauth(undefined, unauthorizeXAddress);
        }
        throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'DepositPreauth protobuf provides neither `Authorize` nor `Unauthorize` fields.');
    }
}
exports.default = XrpDepositPreauth;
//# sourceMappingURL=xrp-deposit-preauth.js.map