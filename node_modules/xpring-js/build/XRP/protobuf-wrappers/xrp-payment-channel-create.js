"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const xpring_common_js_1 = require("xpring-common-js");
const xrp_utils_1 = __importDefault(require("../shared/xrp-utils"));
const xrp_currency_amount_1 = __importDefault(require("./xrp-currency-amount"));
/*
 * Represents a PaymentChannelCreate transaction on the XRP Ledger.
 *
 * A PaymentChannelCreate transaction creates a unidirectional channel and funds it with XRP.
 * The address sending this transaction becomes the "source address" of the payment channel.
 *
 * @see: https://xrpl.org/paymentchannelcreate.html
 */
class XrpPaymentChannelCreate {
    /**
     * @param amount Amount of XRP, in drops, to deduct from the sender's balance and set aside in this channel.
     *                While the channel is open, the XRP can only go to the Destination address.
     *                When the channel closes, any unclaimed XRP is returned to the source address's balance.
     * @param destinationXAddress Address and (optional) destination tag to receive XRP claims against this channel,
     *                            encoded as an X-address (see https://xrpaddress.info/).
     *                            This is also known as the "destination address" for the channel.
     *                            Cannot be the same as the sender (Account).
     * @param settleDelay Amount of time the source address must wait before closing the channel if it has unclaimed XRP.
     * @param publicKey The public key of the key pair the source will use to sign claims against this channel, in hexadecimal.
     *                  This can be any secp256k1 or Ed25519 public key.
     * @param cancelAfter (Optional) The time, in seconds since the Ripple Epoch, when this channel expires.
     *                    Any transaction that would modify the channel after this time closes the channel without otherwise affecting it.
     *                    This value is immutable; the channel can be closed earlier than this time but cannot remain open after this time.)
     */
    constructor(amount, destinationXAddress, settleDelay, publicKey, cancelAfter) {
        this.amount = amount;
        this.destinationXAddress = destinationXAddress;
        this.settleDelay = settleDelay;
        this.publicKey = publicKey;
        this.cancelAfter = cancelAfter;
    }
    /**
     * Constructs an XrpPaymentChannelCreate from a PaymentChannelCreate protocol buffer.
     *
     * @param paymentChannelCreate a PaymentChannelCreate (protobuf object) whose field values will be used to construct an XrpPaymentChannelCreate
     * @return an XrpPaymentChannelCreate with its fields set via the analogous protobuf fields.
     * @see https://github.com/ripple/rippled/blob/3d86b49dae8173344b39deb75e53170a9b6c5284/src/ripple/proto/org/xrpl/rpc/v1/transaction.proto#L272
     */
    static from(paymentChannelCreate, xrplNetwork) {
        var _a, _b, _c, _d, _e, _f, _g;
        const amountCurrencyAmount = (_a = paymentChannelCreate.getAmount()) === null || _a === void 0 ? void 0 : _a.getValue();
        if (amountCurrencyAmount === undefined) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'PaymentChannelCreate protobuf does not contain `amount` field.');
        }
        const amount = xrp_currency_amount_1.default.from(amountCurrencyAmount);
        const destination = (_c = (_b = paymentChannelCreate
            .getDestination()) === null || _b === void 0 ? void 0 : _b.getValue()) === null || _c === void 0 ? void 0 : _c.getAddress();
        if (!destination) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'PaymentChannelCreate protobuf does not contain `destination` field.');
        }
        const destinationTag = (_d = paymentChannelCreate.getDestinationTag()) === null || _d === void 0 ? void 0 : _d.getValue();
        const destinationXAddress = xrp_utils_1.default.encodeXAddress(destination, destinationTag, xrplNetwork == xpring_common_js_1.XrplNetwork.Test || xrplNetwork == xpring_common_js_1.XrplNetwork.Dev);
        if (!destinationXAddress) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Cannot construct XAddress from PaymentChannelCreate protobuf `destination` and `destinationTag` fields.');
        }
        const settleDelay = (_e = paymentChannelCreate.getSettleDelay()) === null || _e === void 0 ? void 0 : _e.getValue();
        if (settleDelay === undefined) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'PaymentChannelCreate protobuf does not contain `settleDelay` field.');
        }
        const publicKey = (_f = paymentChannelCreate.getPublicKey()) === null || _f === void 0 ? void 0 : _f.getValue_asB64();
        if (!publicKey) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'PaymentChannelCreate protobuf does not contain `publicKey` field.');
        }
        const cancelAfter = (_g = paymentChannelCreate.getCancelAfter()) === null || _g === void 0 ? void 0 : _g.getValue();
        return new XrpPaymentChannelCreate(amount, destinationXAddress, settleDelay, publicKey, cancelAfter);
    }
}
exports.default = XrpPaymentChannelCreate;
//# sourceMappingURL=xrp-payment-channel-create.js.map