"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const xpring_common_js_1 = require("xpring-common-js");
const xrp_utils_1 = __importDefault(require("../shared/xrp-utils"));
const xrp_currency_amount_1 = __importDefault(require("./xrp-currency-amount"));
/*
 * Represents an EscrowCreate transaction on the XRP Ledger.
 *
 * An EscrowCreate transaction sequesters XRP until the escrow process either finishes or is canceled.
 *
 * @see: https://xrpl.org/escrowcreate.html
 */
class XrpEscrowCreate {
    /**
     * @param amount Amount of XRP, in drops, to deduct from the sender's balance and escrow.
     *                Once escrowed, the XRP can either go to the Destination address (after the FinishAfter time)
     *                or returned to the sender (after the CancelAfter time).
     * @param destinationXAddress Address and (optional) destination tag to receive escrowed XRP, encoded as an X-address.
     *                            (See https://xrpaddress.info/)
     * @param cancelAfter (Optional) The time, in seconds since the Ripple Epoch, when this escrow expires.
     *                    This value is immutable; the funds can only be returned the sender after this time.
     * @param finishAfter (Optional) The time, in seconds since the Ripple Epoch, when the escrowed XRP can be released to the recipient.
     *                    This value is immutable; the funds cannot move until this time is reached.
     * @param condition (Optional) Hex value representing a PREIMAGE-SHA-256 crypto-condition.
     *                   The funds can only be delivered to the recipient if this condition is fulfilled.
     */
    constructor(amount, destinationXAddress, cancelAfter, finishAfter, condition) {
        this.amount = amount;
        this.destinationXAddress = destinationXAddress;
        this.cancelAfter = cancelAfter;
        this.finishAfter = finishAfter;
        this.condition = condition;
    }
    /**
     * Constructs an XrpEscrowCreate from an EscrowCreate protocol buffer.
     *
     * @param escrowCreate an EscrowCreate (protobuf object) whose field values will be used to construct an XrpEscrowCreate
     * @return an XrpEscrowCreate with its fields set via the analogous protobuf fields.
     * @see https://github.com/ripple/rippled/blob/3d86b49dae8173344b39deb75e53170a9b6c5284/src/ripple/proto/org/xrpl/rpc/v1/transaction.proto#L178
     */
    static from(escrowCreate, xrplNetwork) {
        var _a, _b, _c, _d, _e, _f, _g;
        // amount is a required field
        const amountCurrencyAmountProto = (_a = escrowCreate.getAmount()) === null || _a === void 0 ? void 0 : _a.getValue();
        if (!amountCurrencyAmountProto) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'EscrowCreate protobuf is missing required `amount` field.');
        }
        const amount = xrp_currency_amount_1.default.from(amountCurrencyAmountProto);
        if (amount.drops == undefined) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'EscrowCreate protobuf `amount` field does not represent XRP.');
        }
        const destination = (_c = (_b = escrowCreate.getDestination()) === null || _b === void 0 ? void 0 : _b.getValue()) === null || _c === void 0 ? void 0 : _c.getAddress();
        if (!destination) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'EscrowCreate protobuf is missing required `destination` field.');
        }
        const destinationTag = (_d = escrowCreate.getDestinationTag()) === null || _d === void 0 ? void 0 : _d.getValue();
        const destinationXAddress = xrp_utils_1.default.encodeXAddress(destination, destinationTag, xrplNetwork == xpring_common_js_1.XrplNetwork.Test || xrplNetwork == xpring_common_js_1.XrplNetwork.Dev);
        // destinationXAddress is a required field
        if (!destinationXAddress) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'Cannot construct XAddress from EscrowCreate protobuf `destination` and `destinationTag` fields.');
        }
        const cancelAfter = (_e = escrowCreate.getCancelAfter()) === null || _e === void 0 ? void 0 : _e.getValue();
        const finishAfter = (_f = escrowCreate.getFinishAfter()) === null || _f === void 0 ? void 0 : _f.getValue();
        if (cancelAfter == undefined && finishAfter == undefined) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'EscrowCreate protobuf is missing at least one of the `cancelAfter` and `finishAfter` fields.');
        }
        if (cancelAfter != undefined &&
            finishAfter != undefined &&
            cancelAfter <= finishAfter) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'EscrowCreate protobuf `finishAfter` field is not before `cancelAfter` field.');
        }
        const condition = (_g = escrowCreate.getCondition()) === null || _g === void 0 ? void 0 : _g.getValue_asB64();
        if (finishAfter == undefined && condition == undefined) {
            throw new __1.XrpError(__1.XrpErrorType.MalformedProtobuf, 'EscrowCreate protobuf is missing at least one of the `finishAfter` and `condition` fields.');
        }
        return new XrpEscrowCreate(amount, destinationXAddress, cancelAfter, finishAfter, condition);
    }
}
exports.default = XrpEscrowCreate;
//# sourceMappingURL=xrp-escrow-create.js.map