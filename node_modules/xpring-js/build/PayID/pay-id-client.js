"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable max-classes-per-file */
const xpring_common_js_1 = require("xpring-common-js");
const pay_id_error_1 = __importStar(require("./pay-id-error"));
const api_1 = require("./Generated/api");
const PAYID_API_VERSION = '1.0';
/**
 * A client for PayID.
 */
class PayIdClient {
    /**
     * Initialize a new PayIdClient.
     *
     * @param useHttps Whether to cuse HTTPS when making PayID requests. Most users should set this to 'true' to avoid
     *                 Man-in-the-Middle attacks. Exposed as an option for testing purposes. Defaults to true.
     */
    constructor(useHttps = true) {
        this.useHttps = useHttps;
    }
    /**
     * Retrieve the crypto address associated with a PayID on the given network.
     *
     * @see https://docs.payid.org/payid-headers
     *
     * @param payId The PayID to resolve.
     * @param network The network to resolve on.
     */
    async cryptoAddressForPayId(payId, network) {
        const addresses = await this.addressesForPayIdAndNetwork(payId, network);
        // With a specific network, exactly one address should be returned by a PayID lookup.
        if (addresses.length === 1) {
            return addresses[0].addressDetails;
        }
        else {
            return Promise.reject(new pay_id_error_1.default(pay_id_error_1.PayIdErrorType.UnexpectedResponse, 'Received more addresses than expected'));
        }
    }
    /**
     * Retrieve all addresses associated with a PayId.
     *
     * @param payId The PayID to resolve.
     */
    async allAddressesForPayId(payId) {
        return this.addressesForPayIdAndNetwork(payId, 'payid');
    }
    /**
     * Return an array of {@link Address}es that match the inputs.
     *
     * @param payId The PayID to resolve.
     * @param network The network to resolve on.
     */
    async addressesForPayIdAndNetwork(payId, network) {
        var _a;
        const payIdComponents = PayIdClient.parsePayId(payId);
        const basePath = this.useHttps
            ? `https://${payIdComponents.host}`
            : `http://${payIdComponents.host}`;
        // Swagger API adds the leading '/' in path automatically because it is part of the endpoint.
        const path = payIdComponents.path.substring(1);
        const api = new api_1.DefaultApi(undefined, basePath);
        const accept = `application/${network}+json`;
        const options = PayIdClient.makeOptionsWithAcceptTypes(accept);
        try {
            const result = await api.resolvePayID(path, options);
            // Ensure the retrieved result matched the requested type.
            const contentType = result.headers['content-type'];
            if (!contentType.includes(accept)) {
                throw new pay_id_error_1.default(pay_id_error_1.PayIdErrorType.UnexpectedResponse, 'Received bad Content-Type');
            }
            const data = result.data;
            if (data === null || data === void 0 ? void 0 : data.addresses) {
                return data.addresses;
            }
            else {
                return Promise.reject(new pay_id_error_1.default(pay_id_error_1.PayIdErrorType.UnexpectedResponse, 'Too many addresses returned'));
            }
        }
        catch (error) {
            if (((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) === 404) {
                const message = `Could not resolve ${payId} on network ${network}`;
                return Promise.reject(new pay_id_error_1.default(pay_id_error_1.PayIdErrorType.MappingNotFound, message));
            }
            else {
                const message = PayIdClient.messageFromMaybeHttpError(error);
                return Promise.reject(new pay_id_error_1.default(pay_id_error_1.PayIdErrorType.UnexpectedResponse, message));
            }
        }
    }
    /**
     * Try to create a pretty formatted error message given an error which may be an HTTP error.
     *
     * @param error An error which may be an HTTP error.
     * @returns A sane message for upstream errors.
     */
    static messageFromMaybeHttpError(error) {
        var _a, _b, _c, _d;
        // Try to nicely form an error if the error is the result of an HTTP request, fall back to
        // just printing the error otherwise.
        return ((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) ? `${(_b = error.response) === null || _b === void 0 ? void 0 : _b.status}: ${(_d = (_c = error.response) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d.message}`
            : error.message;
    }
    /**
     * Make a set of options for the API that include a header with `Accept` set to the given value.
     *
     * @param acceptType The value for the `Accept` header.
     * @returns An options object that can be passed to an api.
     */
    static makeOptionsWithAcceptTypes(acceptType) {
        const headers = {
            Accept: acceptType,
            'PayID-Version': PAYID_API_VERSION,
        };
        const options = {
            headers,
        };
        return options;
    }
    /**
     * Parse a payID to a host and path.
     */
    static parsePayId(payId) {
        const payIdComponents = xpring_common_js_1.PayIdUtils.parsePayId(payId);
        if (!payIdComponents) {
            throw pay_id_error_1.default.invalidPayId;
        }
        return {
            host: payIdComponents.host,
            path: payIdComponents.path,
        };
    }
}
exports.default = PayIdClient;
//# sourceMappingURL=pay-id-client.js.map